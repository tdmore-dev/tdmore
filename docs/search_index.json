[
["index.html", "TDMore: an R package for therapeutic drug monitoring Welcome to TDMore", " TDMore: an R package for therapeutic drug monitoring Ruben Faelens, Nicolas Luyckx, Quentin Leirens, Thomas Bouillon 2018-11-13 Welcome to TDMore We’d like to welcome you on the TDMore bookdown site. Get started as quick as possible with tdmore, an R package that provides a global framework for making Therapeutic Drug Monitoring easy. You’ll get information on the package itself, its installation, interesting use cases and much more. Please note that this project does not include a license. This means that all work is under exclusive copyright. Nobody else can use, copy, distribute or modify this work (more details in Chapter 3) "],
["preface.html", "Preface About this book Acknowledgements", " Preface TDMore provides an easy interface to execute post-hoc bayesian estimation of individual profiles, and to find the best dose to put the patient on target. The package is intended to make it easy to define your own models, and easily create a dose decision support tool for physicians. About this book This book provides guidance on the use of TDMore and serves as a basic reference manual. We assume that users have some notions in PK/PD modeling and simulation and are familiar with the R language. The installation of TDMore and related software and packages is described in Chapter 2. Acknowledgements We would like to thank all the people who are contributing to this project. "],
["intro.html", "Chapter 1 Introduction 1.1 Prerequisites", " Chapter 1 Introduction 1.1 Prerequisites The TDMore framework is based on the R programming language, a free sofware environment for statistical computing. TDMore relies on a series of R open-source packages. In particular, it depends on: RxODE(An R package for simulating PK/PD models. This package is intensively used by TDMore to predict data) nlmixr(An R package for estimating PK/PD model parameters. Although TDMore also estimates model parameters, it does not rely on the nlmixr for the estimation part. However, this package is used for its nice way of defining PK/PD models.) More information on the installation of packages and software can be found in Chapter 2. "],
["install.html", "Chapter 2 Installation", " Chapter 2 Installation TDMore depends on package RxODE, which requires a working C and fortran compiler to work. Installation procedure can be found here. Once RxODE installed, simply execute the following command in the R console: devtools::install_github(&quot;tdmore-dev/tdmore&quot;) If you would like to install the package with all its vignettes, please run the following command instead: devtools::install_github(&quot;tdmore-dev/tdmore&quot;, build_vignettes = TRUE) "],
["license.html", "Chapter 3 License", " Chapter 3 License This project does not include a license. This means that all work is under exclusive copyright. Nobody else can use, copy, distribute or modify this work. The Github terms of service apply. We allow others to view and fork the repository. Please note that this is not sufficient to then copy, distribute or modify this work further. Please see https://choosealicense.com/no-permission/ for more information. Through publishing, we allow others to use this R package and to perform dose adaptation. Installing this package using devtools::install_github is allowed. The official copyright holder of this work is the KU Leuven university. "],
["tdmore-api.html", "Chapter 4 TDMore API 4.1 Model definition 4.2 Regimen definition 4.3 Model simulation 4.4 Parameter estimation 4.5 Dose recommendation 4.6 Plotting the intermediate steps 4.7 Extending TDMore", " Chapter 4 TDMore API The following section shows an overview of the main methods from the TDMore API and tells you how to use them. 4.1 Model definition The TDMore model can be built using 3 different ways. Its model definition can be: a nlmixr model a RxODE model a custom algebraic model These 3 ways will be explained in the next sections. 4.1.1 Build a TDMore object from a nlxmir model Let’s implement a basic 1-compartment PK model in nlmixr. The model code is divided in two different blocks. The ‘ini’ block is used to define all the model parameter values (commonly called theta’s, omega’s and sigma’s in PK/PD modelling language) while the ‘model’ blocks defines all the equations of the model. The nlmixr function is implemented as follows: modelCode1 &lt;- function() { ini({ TVKA &lt;- 1 # THETA on KA TVV &lt;- 70 # THETA on V TVCL &lt;- 4 # THETA on CL EKA ~ 0.3 # ETA on KA (OMEGA, variance) EV ~ 0.3 # ETA on V (OMEGA, variance) ECL ~ 0.3 # ETA on CL (OMEGA, variance) SIGMA &lt;- 0.1 # 10% CV proportional error }) model({ KA &lt;- TVKA*exp(EKA) V &lt;- TVV*exp(EV) CL &lt;- TVCL*exp(ECL) d/dt(depot) = -KA*depot d/dt(center) = KA*depot - CL/V*center CONC = center/V CONC ~ prop(SIGMA) }) } A TDMore object can then be instantiated by running the following snippet: library(tdmore) library(nlmixr) tdmore1 &lt;- nlmixrUI(modelCode1) %&gt;% tdmore() Your model is ready to use. Have a look at the content by calling: summary(tdmore1) ## Structural model: RxODE ## ## Parameters: ## name var cv ## EKA 0.3 0.5477226 ## EV 0.3 0.5477226 ## ECL 0.3 0.5477226 ## ## Covariates: / ## ## Residual error model: ## name additiveError proportionalError exponentialError ## CONC 0 0.1 0 This summary tells you the model contains 3 parameters: EKA, EV and ECL. These parameters will be estimated by TDMore to fit individual observations as best as possible. The model does not have any covariates (to see how covariates are included, go to section X). Output variable is the ‘CONC’ variable. The residual error model on this variable is proportional. Please note that the underlying structural model is RxODE, not nlxmir. This is because the nlxmir model is automatically converted into a RxODE model. The RxODE package is used extensively in TDMore to simulate data. 4.1.2 Build a TDMore object from an RxODE model The same TDMore object can be based on a RxODE model as well. This is done as follows: modelCode2 &lt;- &quot; TVKA = 1 TVV = 70 TVCL = 4 KA &lt;- TVKA * exp(EKA) V &lt;- TVV * exp(EV) CL &lt;- TVCL * exp(ECL) d/dt(depot) = -KA*depot d/dt(center) = KA*depot - CL/V*center CONC = center/V &quot; Note that the model is a character vector and not a function anymore. It does not include the ETA’s (and related OMEGA values). Furthemore, the residual error model is omitted. The missing information needs to be passed to TDMore as follows (arguments omega and res_var): library(tdmore) library(RxODE) omegaMatrix &lt;- vectorToDiagonalMatrix(c(EKA=0.3, EV=0.3, ECL=0.3)) errorModel &lt;- errorModel(&quot;CONC&quot;, prop=0.1) tdmore2 &lt;- RxODE(modelCode2) %&gt;% tdmore(omega=omegaMatrix, res_var=list(errorModel)) The omega matrix is a 3x3 matrix. Only the diagonal is used as you can see. However, correlations can be added if needed. Your model is now ready to use. It can be summarised this way: summary(tdmore2) ## Structural model: RxODE ## ## Parameters: ## name var cv ## EKA 0.3 0.5477226 ## EV 0.3 0.5477226 ## ECL 0.3 0.5477226 ## ## Covariates: / ## ## Residual error model: ## name additiveError proportionalError exponentialError ## CONC 0 0.1 0 This summary is the exact same copy as the previous one! 4.1.3 Build your own algebraic model Finally, TDMore can also work with algebraic models. To do so, the model definition function must return a object of class algebraic_definition. In particular, it must override the predictFunction(times, regimen, ...) which returns the output variable according to the times vector and specified regimen. The following code shows how the algebraic model can be implemented: modelCode3 &lt;- function(THETA=list(KA=1, V=70, CL=4), OMEGA=list(KA=0.3, V=0.3, CL=0.3)) { return(structure(list( predictFunction = function(times, regimen, EKA, EV, ECL) { V = THETA$V * exp(EV) CL = THETA$CL * exp(ECL) KA = THETA$KA * exp(EKA) k = CL / V t = times CONC &lt;- rep(0, length(times)) for(i in seq(1, nrow(regimen))) { # Iterate over all regimen rows tD = regimen$TIME[i] D = regimen$AMT[i] II = regimen$II[i] # A number, 0, or NULL if(!is.null(II) &amp;&amp; II &gt; 0) { # Keep repeating the dose until we are past the last observation time nbrDoses &lt;- row$ADDL while(tD &lt;= max(t) &amp;&amp; nbrDoses &gt; 0) { CONC &lt;- CONC + ifelse(t &gt;= tD, D/V * (KA/(KA-k)) * (exp(-k*(t-tD)) - exp(-KA*(t-tD))), 0) # Algebraic solution of 1-cpt-model tD &lt;- tD + II nbrDoses &lt;- nbrDoses - 1 } } else { # Single administration CONC &lt;- CONC + ifelse(t &gt;= tD, D/V * (KA/(KA-k)) * (exp(-k*(t-tD)) - exp(-KA*(t-tD))), 0) # Algebraic solution of 1-cpt-model } } return(CONC) }, omega = vectorToDiagonalMatrix(list(EKA=OMEGA$KA, EV=OMEGA$V, ECL=OMEGA$CL))), class = &quot;algebraic_definition&quot;)) } The algebraic function definition needs to be passed to the algebraic function. This creates an algebraic model compatible with TDMore. library(tdmore) errorModel &lt;- errorModel(&quot;CONC&quot;, prop=0.1) tdmore3 &lt;- algebraic(modelCode3()) %&gt;% tdmore(res_var=list(errorModel)) summary(tdmore3) ## Structural model: algebraic ## ## Parameters: ## name var cv ## EKA 0.3 0.5477226 ## EV 0.3 0.5477226 ## ECL 0.3 0.5477226 ## ## Covariates: / ## ## Residual error model: ## name additiveError proportionalError exponentialError ## CONC 0 0.1 0 4.1.4 Add model covariates Let’s assume the weight is a covariate in the previous 1-compartment model. It can be added in the model as follows: modelCode1_WT &lt;- function() { ini({ TVKA &lt;- 1 # THETA on KA TVV &lt;- 70 # THETA on V TVCL &lt;- 4 # THETA on CL EKA ~ 0.3 # ETA on KA (OMEGA, variance) EV ~ 0.3 # ETA on V (OMEGA, variance) ECL ~ 0.3 # ETA on CL (OMEGA, variance) SIGMA &lt;- 0.1 # 10% CV proportional error }) model({ KA &lt;- TVKA*exp(EKA) V &lt;- TVV*(WT/70)*exp(EV) CL &lt;- TVCL*((WT/70)**0.75)*exp(ECL) d/dt(depot) = -KA*depot d/dt(center) = KA*depot - CL/V*center CONC = center/V CONC ~ prop(SIGMA) }) } Now, the TDMore object can be created and printed. library(tdmore) library(nlmixr) tdmore1_WT &lt;- nlmixrUI(modelCode1_WT) %&gt;% tdmore() print(tdmore1_WT) # Print may be seen as a short &#39;summary&#39; ## Structural model: RxODE ## Parameters: EKA EV ECL ## Covariates: WT ## Output(s): CONC Weight covariate has been well detected by TDMore! 4.2 Regimen definition The regimen definition in TDMore is relatively close to the NONMEM definition. In TDMore, the regimen is defined as a dataframe. Each row indicates a new dosing scheme. Supported column types are: TIME: time of first dose AMT: amount of the dose II (optional): dose interval between multiple doses ADDL (optional): additional doses, to be used in combination with II RATE (optional): defines the infusion time, if not specified, dose is a bolus given at once at t=TIME CMT (optional): the compartment number (1=depot, 2=center, 3=periph) Example 1: the following snippet will give a 150mg dose every day for a week. regimen1 &lt;- data.frame(TIME=0, AMT=150, II=24, ADDL=7) This is strictly equivalent to the following form: regimen1 &lt;- data.frame(TIME=c(0,1,2,3,4,5,6)*24, AMT=150) Example 2: let’s now infuse this dose in the central compartment instead (CMT=2), for a week. This is translated into the following dataframe: regimen2 &lt;- data.frame(TIME=0, AMT=150, II=24, ADDL=7, CMT=2) Note that infusions (defined with RATE) are injected into the central compartment by default. In the next section, you will learn how to check your model and regimen are well implemented by running simulations. 4.3 Model simulation Simulations in TDMore are done using the predict() function. Let’s have a closer look to its arguments: object: this can be a tdmore or a tdmorefit (see section 4.4) object newdata: numeric vector with all times or a dataframe with a TIME column and all the needed output variables regimen: the treatment regimen (as defined in section 4.2) parameters: the parameter values to use, missing values are taken from the population covariates: the covariates values. They can be time-varying (see section X). se: whether to add residual error level: how much residual error to add, e.g. 0.95 Example 1a: Simulate the first model for a week without residual error times &lt;- seq(0, 24*7-1, by=1) data1a &lt;- predict(tdmore1, newdata=times, regimen=regimen1) head(data1a) ## time KA V CL CONC depot center TIME ## 1 0 1 70 4 0.000000 150.000000 0.00000 0 ## 2 1 1 70 4 1.310408 55.181934 91.72857 1 ## 3 2 1 70 4 1.719699 20.300319 120.37894 2 ## 4 3 1 70 4 1.801530 7.468069 126.10712 3 ## 5 4 1 70 4 1.766713 2.747346 123.66993 4 ## 6 5 1 70 4 1.692589 1.010691 118.48126 5 Because newdata is provided as numeric (with no specified output column), all variables are output. Example 1b: Simulate the first model for a week with residual error data1b &lt;- predict(tdmore1, newdata=times, regimen=regimen1, se=T, level=0.95) head(data1b) ## time KA V CL CONC depot center TIME CONC.upper CONC.lower ## 1 0 1 70 4 0.000000 150.000000 0.00000 0 0.000000 0.000000 ## 2 1 1 70 4 1.310408 55.181934 91.72857 1 1.053573 1.567243 ## 3 2 1 70 4 1.719699 20.300319 120.37894 2 1.382644 2.056754 ## 4 3 1 70 4 1.801530 7.468069 126.10712 3 1.448437 2.154624 ## 5 4 1 70 4 1.766713 2.747346 123.66993 4 1.420444 2.112983 ## 6 5 1 70 4 1.692589 1.010691 118.48126 5 1.360848 2.024331 As you can see, lower and upper bounds on the concentration are provided. Example 1c: Simulate the first model for a week with residual error and output selection data1c &lt;- predict(tdmore1, newdata=data.frame(TIME=times, CONC=NA), regimen=regimen1, se=T, level=0.95) head(data1c) ## TIME CONC CONC.upper CONC.lower ## 1 0 0.000000 0.000000 0.000000 ## 2 1 1.310408 1.053573 1.567243 ## 3 2 1.719699 1.382644 2.056754 ## 4 3 1.801530 1.448437 2.154624 ## 5 4 1.766713 1.420444 2.112983 ## 6 5 1.692589 1.360848 2.024331 Only the concentration is returned in the previous dataframe. Example 2: Compare the 4 models previously described in section 4.1 data1 &lt;- predict(tdmore1, newdata=data.frame(TIME=times, CONC=NA), regimen=regimen1) data1$model &lt;- factor(&quot;nlmixr model&quot;) data2 &lt;- predict(tdmore2, newdata=data.frame(TIME=times, CONC=NA), regimen=regimen1) data2$model &lt;- factor(&quot;RxODE model&quot;) data3 &lt;- predict(tdmore3, newdata=data.frame(TIME=times, CONC=NA), regimen=regimen1) data3$model &lt;- factor(&quot;algebraic model&quot;) data4 &lt;- predict(tdmore1_WT, newdata=data.frame(TIME=times, CONC=NA), regimen=regimen1, covariates=c(WT=50)) data4$model &lt;- factor(&quot;nlxmir model with WT covariate&quot;) library(ggplot2) ggplot(data=rbind(data1, data2, data3, data4), aes(x=TIME, y=CONC, group=model)) + geom_line(aes(color=model)) The plot above shows that the first 3 models are equivalent. The last model with the covariate is different because a covariate of WT=50 is used (this implies a lower clearance). 4.4 Parameter estimation Parameter estimation section. 4.5 Dose recommendation 4.6 Plotting the intermediate steps 4.7 Extending TDMore "],
["vignettes.html", "Chapter 5 Vignettes 5.1 Running TDMore 5.2 Multiple endpoints 5.3 Example: Detecting non-adherence", " Chapter 5 Vignettes 5.1 Running TDMore What’s TDMore? TDMore is an R package that attemps to provide a global framework for making Therapeutic Drug Monitoring software. It is designed not only for the pharmacometricians but also for the physicians. Creating your model There are several ways telling TDMore what your model is. The easiest way is to provide the model in the form of a nxlmir model. The following example shows how a 2-compartment-PK model can be written. For the purpose of this demonstration, the ‘Meropenem’ PK model will be used. As Meropenem is given by injection into a vein, the absorption compartment is omitted. library(nlmixr) modelCode &lt;- function(){ ini({ TVV1 &lt;- 24.4; TVV2 &lt;- 7.01; TVQ &lt;- 4.97; TVCL &lt;- 9.87; ECL ~ 0.194 # This value corresponds to OMEGA_CL (44% SD) EV1 ~ 0.287 # This value corresponds to OMEGA_V1 (54% SD) EPS_PROP &lt;- 0.371 # Proportional error (37% SD) }) model({ CL &lt;- TVCL * exp(ECL) V1 &lt;- TVV1 * exp(EV1) V2 &lt;- TVV2 Q &lt;- TVQ K12 &lt;- Q/V1 K21 &lt;- Q/V2 d/dt(center) = - CL/V1 * center - K12*center + K21 * periph d/dt(periph) = K12*center - K21 * periph CONC = center / V1 CONC ~ prop(EPS_PROP) # Proportional error linked to the PK model }) } Once the model is created, a TDMore object can be instantiated as follows: library(tdmore) nlmixrUI &lt;- nlmixrUI(modelCode) tdmore &lt;- tdmore(nlmixrUI) The TDMore object is now ready for use. Predicting new data TDMore can be used to run simulations, based on the model defined in the previous step. For doing so, the regimen first needs to be specified. In the case of Meropenem, an 30-min injection is given into the central compartment every 8 hour. This can be written as follows: regimen &lt;- data.frame( TIME=c(0, 8, 16), # Every 8 hour and for 1 day, an injection is given AMT=c(1000, 1000, 1000), # 1g is administered RATE=c(1000, 1000, 1000)/0.5 # 30-minute infusion (rate=dose/infusion time) ) Let’s now simulate the population PK model for 1 day. This can be done using the TDMore predict() function. A dataframe with all the times to predict (and respective NA concentration) is given to the ‘newdata’ argument. Field ‘se’ is set to true, it tells TDMore we are interested to simulate the model with residual variability. data &lt;- predict( object = tdmore, newdata = data.frame(TIME = seq(0, 24, by = 0.5), CONC = NA), regimen = regimen, se = TRUE ) library(ggplot2) ggplot(data, aes(x=TIME, y=CONC)) + geom_ribbon(aes(fill=&quot;Population&quot;, ymin=CONC.lower, ymax=CONC.upper), fill=&quot;steelblue2&quot;, alpha=0.15) + geom_line(aes(color=&quot;Population&quot;), data=data) + scale_color_manual(values=c(&quot;steelblue2&quot;)) + scale_y_log10() The plot above shows the median of the population (typical profile) and its 95% confidence interval. The range of the confidence interval can be changed using the argument ‘level’. Estimating individual parameters This section will show you how the individual parameters can be estimated, based on some observed data. Let’s first estimate the parameters of a typical individual. This is achieved by calling the estimate() function. pred &lt;- estimate(tdmore = tdmore, regimen = regimen) coef(pred) ## ECL EV1 ## 0 0 Both eta’s ECL and EV1 have been estimated to 0. This is not surprising, as zero eta’s best describe the population average. We can also look at the uncertainty on these estimates. vcov(pred) ## ECL EV1 ## ECL 0.194 0.000 ## EV1 0.000 0.287 This uncertainty is equal to the population inter-individual variability (OMEGA matrix). Now, let’s assume blood samples have been collected for a subject X at different times. For example, blood samples were collected at times 9h and 16h on the first day. This can be translated in TDMore as follows (note that the concentrations are purely fictive): observed &lt;- data.frame(TIME=c(9, 15), CONC=c(30, 2)) We can ask TDMore to re-estimate the parameters for this specific individual: ipred &lt;- estimate(tdmore = tdmore, observed = observed, regimen = regimen) coef(ipred) ## ECL EV1 ## 0.2597598 -0.1320256 Eta’s obtained by calling ‘coef’ on pred maximise altogether the likelihood for this specific subject. The variance-covariance matrix shows the uncertainty of the individual estimates, and their correlation. vcov(ipred) ## ECL EV1 ## ECL 0.03154084 0.04680264 ## EV1 0.04680264 0.12759969 Predictions for the population (pred) and this specific subject (ipred) can be compared using the following snippet: data &lt;- predict(ipred, newdata=data.frame(TIME=seq(0, 24, 0.1), CONC=NA), se=TRUE) ggplot(data, aes(x=TIME)) + geom_line(aes(color=&quot;Individual&quot;, y=CONC.median)) + geom_ribbon(aes(fill=&quot;Individual&quot;, ymin=CONC.lower, ymax=CONC.upper), fill=&quot;tomato1&quot;, alpha=0.10) + geom_line(aes(color=&quot;Population&quot;, y=CONC), data=predict(pred, newdata=seq(0, 24, 0.1))) + geom_point(aes(y=CONC), data=observed) + scale_color_manual(values=c(&quot;tomato1&quot;, &quot;steelblue2&quot;)) + scale_y_log10() Ipred and pred are shown respectively in red and blue. A 95% confidence interval has been added around the ipred prediction. Note that the default TDMore plotting function can also be used to obtain the exact same plot in a single line of code: plot(ipred, newdata=data.frame(TIME=seq(0.1, 24, by=0.1), CONC=NA)) + scale_y_log10() Finding the right dose to give A very interesting feature in TDMore is the possibility to ask the framework the next dose to be given knowing all the previous observations that were collected and some known end-points. For example, assume we still collected the same two observations on the first day, we would like to find the best first dose to be given on the second day. We would like to reach the trough concentration of 3.10 mg/L as much as possible. This can be expressed, as follows: newRegimen &lt;- data.frame( TIME=c(0, 8, 16, 24), # A fourth dose on the second day is added AMT=c(1000, 1000, 1000, NA), # Adding an unknown dose on the second day RATE=c(1000, 1000, 1000, 1000)/0.5 # 30-minute infusion (rate=dose/infusion time) ) recommendation &lt;- findDose( ipred, regimen = newRegimen, interval = c(100, 5000), target = data.frame(TIME = 32, CONC = 8) ) summary(recommendation) ## $dose ## [1] 4540.072 ## ## $regimen ## TIME AMT RATE ## 1 0 1000.000 2000 ## 2 8 1000.000 2000 ## 3 16 1000.000 2000 ## 4 24 4540.072 2000 The result of the findDose() routine is shown above. It tells us that XXX mg (approximately) is the recommended starting dose on the second day. The following code helps up verify this visually. # Recommended regimen for individual can be directly accessed from the recommendation object ipredRecommendedRegimen &lt;- recommendation$regimen # Population regimen can be updated using the &#39;updateRegimen&#39; method, a 4th dose of 1000 is used predUpdatedRegimen &lt;- updateRegimen(regimen = newRegimen, newDose = 4500) print(predUpdatedRegimen) # Check pred regimen ## TIME AMT RATE ## 1 0 1000 2000 ## 2 8 1000 2000 ## 3 16 1000 2000 ## 4 24 4500 2000 ipred &lt;- estimate(tdmore = tdmore, observed = observed, regimen = ipredRecommendedRegimen) pred &lt;- estimate(tdmore = tdmore, regimen = predUpdatedRegimen) plot(ipred, newdata=seq(0, 32, by=0.1)) + geom_hline(yintercept=8) + scale_y_log10() The plot above demonstrates that the individual is reaching the trough concentration quite well after the first administration on the second day. 5.2 Multiple endpoints Writing and testing the PK model In this vignette, we will learn how TDMore can deal with multiple endpoints. The PK/PD models chosen to illustrate this section are based on the following paper: “Population PK/PD modeling of Sunitinib by dosing schedule in patients with advanced renal cell carcinoma or gastrointestinal stromal tumor.”. Let’s start writing the Sunitinib PK model. library(nlmixr) modelCode &lt;- function(){ ini({ TVCL &lt;- 34.1 TVVc &lt;- 2700 TVKa &lt;- 0.126 TVVp &lt;- 774 TVQ &lt;- 0.688 ECL ~ 0.060516 # 24.6% EVc ~ 0.052900 # 23.0% EKa ~ 2.755600 # 166% EPS_Prop &lt;- 0.417 }) model({ CL &lt;- TVCL * exp(ECL) Vc &lt;- TVVc * exp(EVc) Vp &lt;- TVVp Q &lt;- TVQ K12 &lt;- Q/Vc K21 &lt;- Q/Vp Ke &lt;- CL/Vc Ka &lt;- TVKa*exp(EKa) d/dt(depot) = -Ka*depot d/dt(center) = Ka*depot - Ke*center - K12*center + K21*periph d/dt(periph) = K12*center - K21*periph CONC = center/Vc CONC ~ prop(EPS_Prop) }) } The TDMore object is instantiated as follows: library(tdmore) nlmixrModel &lt;- nlmixrUI(modelCode) m1 &lt;- tdmore(nlmixrModel) A basic regimen can be created to test that the model is running properly. The standard regimen of Sunitinib is 50mg daily for 4 weeks. regimen &lt;- data.frame( TIME=0, # First dose time: t=0h AMT=50, # Dose amount: 50 mg II=24, # Dose interval: 24h ADDL=4*7-1 # Additional doses: 4 weeks ) times &lt;- seq(0, 6*7*24) # Observation times This regimen can be plotted using the default TDMore plotting function. It shows the typical value of the population and the between-subject variability (95% confidence interval). plot(m1, regimen, newdata=times) Adding a PD model Suppose we received a full blood workup: Sunitinib concentration, Alanine aminotransferase (ALT), Aspartate aminotransferase (AST), Absolute neutrophil count (ANC), Platelet count (PC) and Lymphocyte count (LC). We also measured the patient’s diastolic blood pressure (DBP). We can create a single model to predict all of these aspects. In the example below, we will focus on ALT and AST. Please note the mandatory ‘|’ nlmixr syntax used to describe the residual variability of different endpoints. modelCode &lt;- function(){ ini({ # PK model sunitinib TVCL &lt;- 34.1 TVVc &lt;- 2700 TVKa &lt;- 0.126 TVVp &lt;- 774 TVQ &lt;- 0.688 ECL ~ 0.060516 # 24.6% EVc ~ 0.052900 # 23.0% EKa ~ 2.755600 # 166% EPS_Prop &lt;- 0.417 # Proportional error 1 (related to CONC) # PD model ALT TVBASE_AST &lt;- 21.5 TVKout_AST &lt;- 0.0142 TVKpd_AST &lt;- 0.00572 EPS_Prop_AST = 0.257 #25.7% # PD model AST TVBASE_ALT &lt;- 21.2 TVKout_ALT &lt;- 0.00916 TVKpd_ALT &lt;- 0.00401 EPS_Prop_ALT = 0.373 #37.3% # We assume 0.5 correlations in IIV, even though they are not reported in the original paper EBASE_AST + EBASE_ALT ~ c(0.101124, 0.05028021, 0.164025) # 31.8% #40.5% EKout_AST + EKout_ALT ~ c(1.440000, 0.1897367, 1.638400)#120% #128% EKpd_AST + EKpd_ALT ~ c(0.114244, 0.05344249, 0.324900) #33.8% #57.0% }) model({ # PK parameters CL &lt;- TVCL * exp(ECL) Vc &lt;- TVVc * exp(EVc) Vp &lt;- TVVp Q &lt;- TVQ K12 &lt;- Q/Vc K21 &lt;- Q/Vp Ke &lt;- CL/Vc Ka &lt;- TVKa*exp(EKa) # AST parameters BASE_AST &lt;- TVBASE_AST * exp(EBASE_AST) Kout_AST &lt;- TVKout_AST * exp(EKout_AST) Kpd_AST &lt;- TVKpd_AST * exp(EKpd_AST) #mL/ng Kin_AST &lt;- Kout_AST * BASE_AST # ALT parameters BASE_ALT &lt;- TVBASE_ALT * exp(EBASE_ALT) Kout_ALT &lt;- TVKout_ALT * exp(EKout_ALT) Kpd_ALT &lt;- TVKpd_ALT * exp(EKpd_ALT) #mL/ng Kin_ALT &lt;- Kout_ALT * BASE_ALT # PK model d/dt(depot) = -Ka*depot d/dt(center) = Ka*depot - Ke*center - K12*center + K21*periph d/dt(periph) = K12*center - K21*periph CONC = center/Vc * 1000 #ng/mL # AST model AST(0) = BASE_AST d/dt(AST) = Kin_AST - Kout_AST*AST*(1-Kpd_AST*CONC) # ALT model ALT(0) = BASE_ALT d/dt(ALT) = Kin_ALT - Kout_ALT*ALT*(1-Kpd_ALT*CONC) # Residual error models CONC ~ prop(EPS_Prop) | center # Define error model 1 AST ~ prop(EPS_Prop_AST) | AST # error model 2 ALT ~ prop(EPS_Prop_ALT) | ALT # error model 3 }) } nlmixrModel &lt;- nlmixrUI(modelCode) m2 &lt;- tdmore(nlmixrModel, maxsteps=1E3*500) Let’s now have a look at the evolution of these safety signals over time. To have a good overview, we will observe ALT/AST for 4 weeks treatment. The default plot shows once again the typical value and the between-subject variability (95% CI). regimen &lt;- data.frame( TIME=0, AMT=50, II=24, ADDL=4*7 ) times &lt;- seq(0, 6*7*24, by=1) plot(m2, regimen, newdata=data.frame(TIME=times, CONC=NA)) plot(m2, regimen, newdata=data.frame(TIME=times, ALT=NA)) plot(m2, regimen, newdata=data.frame(TIME=times, AST=NA)) Estimating individual parameters We get the values for ALT/AST for a specific individual. These are quite high! observed &lt;- data.frame( TIME=c(0, 2,3,4)*7*24, CONC=NA, ALT=c(21, 40, 42, 43), AST=c(21, 45, 47, 49)) ipred &lt;- estimate(tdmore = m2, observed = observed, regimen = regimen) plot(ipred, newdata=data.frame(TIME=times, CONC=NA)) plot(ipred, newdata=data.frame(TIME=times, ALT=NA)) plot(ipred, newdata=data.frame(TIME=times, AST=NA)) Based on only ALT/AST values, we managed to define the PK inter-individual variability a little better. Indeed, these high ALT/AST values can be best explained through a combination of high sensitivity (EKpd), and a lower clearance (ECL) of the drug. coef(ipred) ## ECL EVc EKa EBASE_AST EBASE_ALT EKout_AST ## -0.13927141 -0.01279161 0.02257760 0.03233717 0.04497159 0.22456560 ## EKout_ALT EKpd_AST EKpd_ALT ## 0.22778905 0.24279322 0.37291944 coef(ipred) / sqrt(diag(m2$omega)) ## ECL EVc EKa EBASE_AST EBASE_ALT EKout_AST ## -0.56614395 -0.05561569 0.01360096 0.10168920 0.11104095 0.18713800 ## EKout_ALT EKpd_AST EKpd_ALT ## 0.17796020 0.71832312 0.65424462 5.3 Example: Detecting non-adherence "],
["about-this-example.html", "Chapter 6 About this example", " Chapter 6 About this example Non-compliance is an important issue endangering the effectiveness of treatments. In COPD, it is estimated that there is a non-compliance of more than 98% for inhaled treatments. In this example, we use TDMore to compare the systemic concentrations of inhaled fluticasone propionate with the population predictions. We show that TDMore can be used to detect severe non-adherence, and to propose corrective action. "],
["the-model.html", "Chapter 7 The model", " Chapter 7 The model Model taken from literature: Soulele, K., et al. “Population pharmacokinetics of fluticasone propionate/salmeterol using two different dry powder inhalers.” European Journal of Pharmaceutical Sciences 80 (2015): 33-42. library(nlmixr) modelCode &lt;- function(){ ini({ TVKa &lt;- 3.87 TVCL &lt;- 659 #L/h TVV1 &lt;- 56900 #L TVV2 &lt;- 5550 #L TVQ &lt;- 259 #L/h EKa ~ 0.04507129 #0.2123**2 ECL ~ 0.1535856 #0.3919**2 EV1 ~ 0.09223369 #0.3037**2 EV2 ~ 0.208301 #0.4564**2 EQ ~ 0.1015697# 0.3187**2 EPS_ADD &lt;- 1.91 # EPS_PROP &lt;- 0.117 }) model({ Ka &lt;- TVKa * exp(EKa) CL &lt;- TVCL * exp(ECL) V1 &lt;- TVV1 * exp(EV1) V2 &lt;- TVV2 * exp(EV2) Q &lt;- TVQ * exp(EQ) K12 &lt;- Q/V1 K21 &lt;- Q/V2 d/dt(center) = - CL/V1 * center - K12*center + K21 * periph d/dt(periph) = K12*center - K21 * periph CONC = center / V1 * 1000 CONC ~ prop(EPS_PROP) + add(EPS_ADD) }) } nlmixrModel &lt;- nlmixrUI(modelCode) library(tdmore) m1 &lt;- tdmore(nlmixrModel) We now define the treatment regimen regimen &lt;- data.frame( TIME=seq(0, by=24, length.out=30), AMT=500 # 500ug standard dose ) adhering &lt;- predict(m1, regimen=regimen, newdata=seq(0, 30*24)) actual &lt;- data.frame( TIME=seq(0, by=24, length.out=30), AMT=500*sample(c(0,1), 30, replace=TRUE) # probability of 50% to not take the dose ) nonAdhering &lt;- predict(m1, regimen=actual, newdata=seq(0, 30*24)) pred &lt;- estimate(m1, regimen=regimen) ggplot(pred, newdata=seq(0, 30*24)) + ipred(mapping=aes(x=TIME, y=CONC)) # labs(x=&quot;Time (hours)&quot;, y=&quot;Concentration (mg/L)&quot;) "],
["is-the-patient-taking-hisher-medication.html", "Chapter 8 Is the patient taking his/her medication?", " Chapter 8 Is the patient taking his/her medication? We can now take a serum sample and evaluate if there is non-adherence. # Take a blood sample observed &lt;- predict(m1, regimen=actual, newdata=data.frame(TIME=30*24+c(-16, 0), CONC=NA)) observed ## TIME CONC ## 1 704 12.42485 ## 2 720 10.20530 # We estimate individual parameters # as if the patient took his medication # properly ipred &lt;- estimate(m1, observed, regimen) coef(ipred) ## EKa ECL EV1 EV2 EQ ## 0.000000000 0.828384249 0.035455547 -0.000201276 0.001489463 ggplot(mapping=aes(x=TIME, y=CONC)) + geom_line(aes(color=&quot;Reality&quot;), data=nonAdhering) + geom_point(data=observed) + geom_line(aes(color=&quot;Population&quot;), data=adhering) + # geom_ribbon(aes(fill=&quot;Population&quot;, ymin=CONC.lower, ymax=CONC.upper), # data=predict(m1, regimen=regimen, newdata=data.frame(TIME=seq(0, 30*24), CONC=NA), se.fit=TRUE), alpha=0.1) + geom_line(aes(color=&quot;Prediction&quot;), data=predict(ipred, regimen=regimen, newdata=data.frame(TIME=seq(0, 30*24), CONC=NA))) standardDeviations &lt;- coef(ipred) / sqrt(diag(m1$omega)) standardDeviations ## EKa ECL EV1 EV2 EQ ## 0.0000000000 2.1137644184 0.1167452994 -0.0004410079 0.0046735564 i &lt;- which(pnorm(abs(standardDeviations)) &gt; 0.975) if(length(i) &gt; 0) { cat(&quot;This patient has unlikely (outside 95% CI) parameter estimates for &quot;, names(i),&quot;. There may be a treatment adherence issue.&quot;) } ## This patient has unlikely (outside 95% CI) parameter estimates for ECL . There may be a treatment adherence issue. "]
]
