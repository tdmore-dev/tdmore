[
["index.html", "TDMore: an R package for in silico assessment of dose individualization strategies Welcome to TDMore", " TDMore: an R package for in silico assessment of dose individualization strategies Ruben Faelens, Nicolas Luyckx, Quentin Leirens, Thomas Bouillon Welcome to TDMore We’d like to welcome you on the TDMore bookdown site. Get started as quick as possible with tdmore, an R package that provides a global framework for the in silico assessment of dose individualization strategies. You’ll get information on the package itself, its installation, interesting use cases and much more. Please note that this project does not include a license. This means that all work is under exclusive copyright. Nobody else can use, copy, distribute or modify this work (more details in Chapter 5) "],
["preface.html", "Preface About this book Acknowledgements", " Preface TDMore is a software solely for training and in silico research purposes that provides an easy interface to execute post-hoc bayesian estimation of parameter vectors of virtual individuals. For training purposes, a dose finding tool to achieve a certain concentration target in a virtual individual is included. The package is intended to make it easy to define your own models, and easily create an educational tool to support dosing decisions decision by physicians via in silico training. TDMore differs from other software for TDM in three aspects: It is a mathematical engine only. You have to provide the model. No clinical models or clinical interpretation is included. If you build dose adaptation software (a medical device!), you need to provide your own model, own clinical interpretation, and especially your own validation (potentially requiring a CE mark). It is a tool for in silico evaluation and validation of dose adaptation approaches. It can be used in a population simulation (to estimate how many virtual subjects would be put on target by a given approach), or in a trial simulation (to estimate study power for a prospective trial on dose adaptation). Other software are designed for use by physicians, on a single individual real patient. It is open-source and can be easily extended or integrated with. About this book This book provides guidance on the use of TDMore and serves as a basic reference manual. We assume that users have some notions in PK/PD modeling and simulation and are familiar with the R language. The installation of TDMore and related software and packages is described in Chapter 3. Acknowledgements We would like to thank all the people who are contributing to this project. "],
["legal-notices.html", "Chapter 1 Legal Notices 1.1 Disclaimer 1.2 Content 1.3 Referrals and links 1.4 Copyright 1.5 Legal validity of this disclaimer", " Chapter 1 Legal Notices 1.1 Disclaimer TDMore has been created for personal use only. The use of any result generated by TDMore is in any case the sole risk and responsibility of the TDMore user. Therapeutic decision should not solely rely on TDMore as information provided by TDMore does not replace clinical judgement. Although TDMore has been validated carefully, there is no guarantee for the accuracy of the provided results. When using TDMore you automatically agree with this disclaimer and the legal notices. 1.2 Content The authors reserve the right not to be responsible for the topicality, correctness, completeness or quality of the information provided. Liability claims regarding damage caused by the use of any information provided, including any kind of information which is incomplete or incorrect, will therefore be rejected. All offers are not-binding and without obligation. Parts of the pages or the complete publication including all offers and information might be extended, changed or partly or completely deleted by the authors without separate announcement. 1.3 Referrals and links The authors are not responsible for any contents linked or referred to from these pages - unless they have full knowledge of illegal contents and would be able to prevent the visitors of this site fromviewing those pages. If any damage occurs by the use of information presented there, only the author of the respective pages might be liable, not the one who has linked to these pages. Furthermore the authors are not liable for any postings or messages published by users of discussion boards, guestbooks or mailinglists provided on these pages. 1.4 Copyright All work is under exclusive copyright by KULeuven and cannot be distributed or modified. You are allowed to install this package for experimentation. Please contact the authors to obtain a license to use this work in a commercial software, or for research. 1.5 Legal validity of this disclaimer This disclaimer is to be regarded as part of the internet publication which you were referred from. If sections or individual terms of this statement are not legal or correct, the content or validity of the other parts remain uninfluenced by this fact. The text of this disclaimer is based on the services of http://www.disclaimer.de "],
["intro.html", "Chapter 2 Introduction 2.1 Prerequisites", " Chapter 2 Introduction 2.1 Prerequisites The TDMore framework is based on the R programming language, a free sofware environment for statistical computing. TDMore relies on a series of R open-source packages. In particular, it depends on: RxODE(An R package for simulating PK/PD models. This package is intensively used by TDMore to predict data) nlmixr(An R package for estimating PK/PD model parameters. Although TDMore also estimates model parameters, it does not rely on the nlmixr for the estimation part. However, this package is used for its nice way of defining PK/PD models.) More information on the installation of packages and software can be found in Chapter 3. "],
["install.html", "Chapter 3 Installation", " Chapter 3 Installation TDMore depends on package RxODE, which requires a working C and fortran compiler to work. Installation procedure can be found here. Once RxODE installed, simply execute the following command in the R console: devtools::install_github(&quot;tdmore-dev/tdmore&quot;) If you would like to install the package with all its vignettes, please run the following command instead: devtools::install_github(&quot;tdmore-dev/tdmore&quot;, build_vignettes = TRUE) "],
["installation-script.html", "Chapter 4 Installation script", " Chapter 4 Installation script The below script can be used to automatically install TDMore. It uses an API key that still needs to be filled in. if(R.version$major != &quot;3&quot; || as.numeric(R.version$minor) &lt; 5.2) { stop(&quot;tdmore requires at least R version 3.5.2 Please install a more recent version from https://cran.r-project.org/bin/windows/base/ You may have to adapt the settings of RStudio in Tools -&gt; Global Options as well.&quot;) } if(!require(devtools)) install.packages(&#39;devtools&#39;) if(!require(tidyverse)) install.packages(&#39;tidyverse&#39;) PAT_TOKEN &lt;- &quot;SECRET&quot; #request the PAT_TOKEN from us to access the repository devtools::install_github(&quot;tdmore-dev/tdmore&quot;, user=&quot;tdmore-training&quot;, auth_token=PAT_TOKEN, upgrade=&quot;never&quot;) tryCatch( { RxODE::RxODE( &quot;d/dt(A0) = -0.5 * A0;&quot; ) }, error=function(e) { stop( &quot;RxODE could not compile a model. This does not stop tdmore from working, nor will it stop you from completing the training. However, you will not be able to use RxODE or nlmixr models. To use nlmixr-style models, you will have to install Rtools. You can find this on https://cran.r-project.org/bin/windows/Rtools/Rtools35.exe &quot; ) }) "],
["license.html", "Chapter 5 License", " Chapter 5 License This project does not include a license. This means that all work is under exclusive copyright. Nobody can use, copy, distribute or modify this work. The Github terms of service apply. We allow others to view and fork the repository. Please note that this is not sufficient to then copy, distribute or modify this work further. Please see https://choosealicense.com/no-permission/ for more information. Through publishing, we allow others to use this R package and to perform dose adaptation. Installing this package using devtools::install_github is allowed. The official copyright holder of this work is the KU Leuven university. "],
["tdmore-api.html", "Chapter 6 TDMore API 6.1 Model definition 6.2 Regimen definition 6.3 Model simulation 6.4 Parameter estimation 6.5 Dose recommendation 6.6 Plotting the intermediate steps 6.7 Extending TDMore", " Chapter 6 TDMore API The following section shows an overview of the main methods of the TDMore API and tells you how to use them. 6.1 Model definition The TDMore model can be built using 3 different ways. Its model definition can be: a nlmixr model a RxODE model a custom algebraic model These 3 ways will be explained in the next sections. 6.1.1 Build a TDMore object from a nlxmir model Let’s implement a basic 1-compartment PK model in nlmixr. The model code is divided in two different blocks. The ‘ini’ block is used to define all the model parameter values (commonly called theta’s, omega’s and sigma’s in PK/PD modelling language) while the ‘model’ blocks defines all the equations of the model. The nlmixr function is implemented as follows: library(nlmixr) modelCode1 &lt;- function() { ini({ TVKA &lt;- 1 # THETA on KA TVV &lt;- 70 # THETA on V TVCL &lt;- 4 # THETA on CL EKA ~ 0.3 # ETA on KA (OMEGA, variance) EV ~ 0.3 # ETA on V (OMEGA, variance) ECL ~ 0.3 # ETA on CL (OMEGA, variance) SIGMA &lt;- 0.1 # 10% CV proportional error }) model({ KA &lt;- TVKA*exp(EKA) V &lt;- TVV*exp(EV) CL &lt;- TVCL*exp(ECL) d/dt(depot) = -KA*depot d/dt(center) = KA*depot - CL/V*center CONC = center/V CONC ~ prop(SIGMA) }) } A TDMore object can then be instantiated by running the following snippet: library(tdmore) m1 &lt;- nlmixrUI(modelCode1) %&gt;% tdmore() Your model is ready to use. Have a look at its content by calling: summary(m1) ## Structural model: RxODE ## ## Parameters: ## name var cv ## EKA 0.3 0.5477226 ## EV 0.3 0.5477226 ## ECL 0.3 0.5477226 ## ## Covariates: / ## ## Residual error model: ## name type additiveError proportionalError ## CONC proportional 0 0.1 This summary tells you the model contains 3 parameters: EKA, EV and ECL. These parameters will be estimated by TDMore to fit virtual individual observations as best as possible. The model does not have any covariates (to see how covariates are included, go to section X). Output variable is the CONC variable. The residual error model on this variable is proportional. Please note that the underlying structural model is RxODE, not nlxmir. This is because the nlxmir model is automatically converted into a RxODE model. The RxODE package is used extensively in TDMore to simulate data. 6.1.2 Build a TDMore object from an RxODE model The same TDMore object can be based on a RxODE model as well. This is done as follows: modelCode2 &lt;- &quot; TVKA = 1 TVV = 70 TVCL = 4 KA &lt;- TVKA * exp(EKA) V &lt;- TVV * exp(EV) CL &lt;- TVCL * exp(ECL) d/dt(depot) = -KA*depot d/dt(center) = KA*depot - CL/V*center CONC = center/V &quot; Note that the model is a character vector and not a function anymore. It does not include the ETA’s (and related OMEGA values). Furthemore, the residual error model is omitted. The missing information needs to be passed to TDMore as follows (arguments omega and res_var): library(tdmore) library(RxODE) errorModel &lt;- errorModel(&quot;CONC&quot;, prop=0.1) m2 &lt;- RxODE(modelCode2) %&gt;% tdmore(omega=c(EKA=0.3, EV=0.3, ECL=0.3), res_var=list(errorModel)) The omega matrix is a 3x3 matrix. Only the diagonal is used as you can see. However, correlations can be added if needed. Your model is now ready to use. It can be summarised this way: summary(m2) ## Structural model: RxODE ## ## Parameters: ## name var cv ## EKA 0.3 0.5477226 ## EV 0.3 0.5477226 ## ECL 0.3 0.5477226 ## ## Covariates: / ## ## Residual error model: ## name type additiveError proportionalError ## CONC proportional 0 0.1 This summary is the exact same copy as the previous one! 6.1.3 Build your own algebraic model Finally, TDMore can also work with algebraic models. To do so, the model definition function must return a object of class algebraic_definition. In particular, it must override the predictFunction(times, regimen, ...) which returns the output variable according to the times vector and specified regimen. The following code shows how the algebraic model can be implemented: modelCode3 &lt;- function(t, TIME, AMT, EKA, EV, ECL) { V = 70 * exp(EV) CL = 4 * exp(ECL) KA = 1 * exp(EKA) k = CL / V D = AMT tD = TIME # Algebraic solution of 1-cpt-model ifelse(t &gt;= tD, D/V * (KA/(KA-k)) * (exp(-k*(t-tD)) - exp(-KA*(t-tD))), 0) } m3 &lt;- tdmore(algebraic(modelCode3), omega=c(EKA=0.3, EV=0.3, ECL=0.3), res_var=errorModel(prop=0.1) ) summary(m3) ## Structural model: algebraic ## ## Parameters: ## name var cv ## EKA 0.3 0.5477226 ## EV 0.3 0.5477226 ## ECL 0.3 0.5477226 ## ## Covariates: / ## ## Residual error model: ## name type additiveError proportionalError ## CONC proportional 0 0.1 6.1.4 Add model covariates Let’s assume the weight is a covariate in the previous 1-compartment model. It can be added in the model as follows: modelCode1_WT &lt;- function() { ini({ TVKA &lt;- 1 # THETA on KA TVV &lt;- 70 # THETA on V TVCL &lt;- 4 # THETA on CL EKA ~ 0.3 # ETA on KA (OMEGA, variance) EV ~ 0.3 # ETA on V (OMEGA, variance) ECL ~ 0.3 # ETA on CL (OMEGA, variance) SIGMA &lt;- 0.1 # 10% CV proportional error }) model({ KA &lt;- TVKA*exp(EKA) V &lt;- TVV*(WT/70)*exp(EV) CL &lt;- TVCL*((WT/70)**0.75)*exp(ECL) d/dt(depot) = -KA*depot d/dt(center) = KA*depot - CL/V*center CONC = center/V CONC ~ prop(SIGMA) }) } Now, the TDMore object can be created and printed. library(tdmore) library(nlmixr) m1_WT &lt;- nlmixrUI(modelCode1_WT) %&gt;% tdmore() print(m1_WT) # Print may be seen as a short &#39;summary&#39; ## Structural model: RxODE ## Parameters: EKA EV ECL ## Covariates: WT ## Output(s): ## CONC : proportional ( prop= 0.1 ) Weight covariate has been well detected by TDMore! 6.2 Regimen definition The regimen definition in TDMore is relatively close to the NONMEM definition. In TDMore, the regimen is defined as a dataframe. Each row indicates a new dosing scheme. Supported column types are: TIME: time of first dose AMT: amount of the dose II (optional): dose interval between multiple doses ADDL (optional): additional doses, to be used in combination with II RATE (optional): defines the infusion time, if not specified, dose is a bolus given at once at t=TIME CMT (optional): the compartment number (1=depot, 2=center, 3=periph) Example 1: the following snippet will give a 150mg dose every day for a week. regimen1 &lt;- data.frame(TIME=0, AMT=150, II=24, ADDL=7) This is strictly equivalent to the following form: regimen1 &lt;- data.frame(TIME=c(0,1,2,3,4,5,6)*24, AMT=150) Example 2: let’s now infuse this dose in the central compartment instead (CMT=2), for a week. This is translated into the following dataframe: regimen2 &lt;- data.frame(TIME=0, AMT=150, II=24, ADDL=7, CMT=2) Note that infusions (defined with RATE) are injected into the central compartment by default. In the next section, you will learn how to check your model and regimen are well implemented by running simulations. 6.3 Model simulation Simulations in TDMore are done using the predict() function. This function can be applied on both tdmore and tdmorefit objects altough their arguments differ a little (see 6.3.1 and 6.3.2) 6.3.1 Predict a tdmore object Let’s have a closer look at the predict.tdmore arguments: object: a tdmore object newdata: numeric vector with all times or a dataframe with a TIME column and all the needed output variables regimen: the treatment regimen (as defined in section 6.2) parameters: the parameter values to use, missing values are taken from the population covariates: the covariates values. They can be time-varying (see section X). se: whether to add residual error level: how much residual error to add, e.g. 0.95 Example 1a: Simulate the first model for a week without residual error times &lt;- seq(0, 24*7-1, by=1) data1a &lt;- predict(m1, newdata=times, regimen=regimen1) head(data1a) TIME KA V CL CONC depot center 0 1 70 4 0&nbsp;&nbsp;&nbsp; 150&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp; 1 1 70 4 1.31 55.2&nbsp; 91.7 2 1 70 4 1.72 20.3&nbsp; 120&nbsp;&nbsp; 3 1 70 4 1.8&nbsp; 7.47 126&nbsp;&nbsp; 4 1 70 4 1.77 2.75 124&nbsp;&nbsp; 5 1 70 4 1.69 1.01 118&nbsp;&nbsp; Because newdata is provided as numeric (with no specified output column), all variables are output. Example 1b: Simulate the first model for a week with residual error data1b &lt;- predict(m1, newdata=times, regimen=regimen1, se=T, level=0.95) head(data1b) TIME KA V CL CONC depot center CONC.lower CONC.upper 0 1 70 4 0&nbsp;&nbsp;&nbsp; 150&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp; 1 1 70 4 1.31 55.2&nbsp; 91.7 1.05 1.57 2 1 70 4 1.72 20.3&nbsp; 120&nbsp;&nbsp; 1.38 2.06 3 1 70 4 1.8&nbsp; 7.47 126&nbsp;&nbsp; 1.45 2.15 4 1 70 4 1.77 2.75 124&nbsp;&nbsp; 1.42 2.11 5 1 70 4 1.69 1.01 118&nbsp;&nbsp; 1.36 2.02 As you can see, lower and upper bounds on the concentration are provided. Example 1c: Simulate the first model for a week with residual error and output selection data1c &lt;- predict(m1, newdata=data.frame(TIME=times, CONC=NA), regimen=regimen1, se=T, level=0.95) head(data1c) TIME CONC CONC.lower CONC.upper 0 0&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp; 1 1.31 1.05 1.57 2 1.72 1.38 2.06 3 1.8&nbsp; 1.45 2.15 4 1.77 1.42 2.11 5 1.69 1.36 2.02 Only the concentration is returned in the previous dataframe. Example 2: Compare the 4 models previously described in section 6.1 data1 &lt;- predict(m1, newdata=data.frame(TIME=times, CONC=NA), regimen=regimen1) data1$model &lt;- factor(&quot;nlmixr model&quot;) data2 &lt;- predict(m2, newdata=data.frame(TIME=times, CONC=NA), regimen=regimen1) data2$model &lt;- factor(&quot;RxODE model&quot;) data3 &lt;- predict(m3, newdata=data.frame(TIME=times, CONC=NA), regimen=regimen1) data3$model &lt;- factor(&quot;algebraic model&quot;) data4 &lt;- predict(m1_WT, newdata=data.frame(TIME=times, CONC=NA), regimen=regimen1, covariates=c(WT=50)) data4$model &lt;- factor(&quot;nlxmir model with WT covariate&quot;) library(ggplot2) ggplot(data=rbind(data1, data2, data3, data4), aes(x=TIME, y=CONC, group=model)) + geom_line(aes(color=model)) The plot above shows that the first 3 models are equivalent. The last model with the covariate is different because a covariate of WT=50 is used (this implies a lower clearance). 6.3.2 Predict a tdmorefit object Arguments of function predict.tdmorefit slightly differ from function predict.tdmore: object: a tdmorefit object newdata: numeric vector with all times or a dataframe with a TIME column and all the needed output variables regimen: the treatment regimen (as defined in section 6.2) parameters: set parameters. If missing, or if only part of the parameters are specified, the other parameters are taken from the tdmorefit object covariates: the covariates values. They can be time-varying (see section X). se.fit: TRUE to provide a confidence interval on the prediction, adding columns xxx.median, xxx.upper and xxx.lower level: the confidence interval, or NA to return all mc.maxpts results mc.maxpts: maximum number of points to sample in Monte Carlo simulation ip.maxpts: maximum number of points to interpolate if newdata is not given The main difference between predict.tdmore and predict.tdmorefit when a confidence interval is asked (respectively se=T or se.fit=T) is that the latter performs a monte-carlo simulation to build a confidence interval on the prediction while the former builds a confidence interval based on the error model. 6.4 Parameter estimation Parameter estimation is done using the estimate() function. This function returns a tdmorefit object. Let’s first discuss all its main arguments in detail: object: this must be a tdmore object observed: data frame with at least a TIME column, and all observed data. The observed data will be compared to the model predictions. If not specified, we estimate the population prediction. covariates: the covariates values. They can be time-varying (see section X). par (optional): starting parameters for the MLE minimization. This must be a numeric vector. Parameters must be ordered. The estimate() function contains a few more arguments allowing to configure the optimisation method. These are detailled in the documentation (try ?tdmore::estimate in the R console). Example: Find parameters of a virtual individual based on virtual observations. Assume we have collected 2 concentrations at 24h and 48h. In the following code, we’d like to estimate the parameters for this virtual individual. observed &lt;- data.frame(TIME=c(24,48), CONC=c(0.4,0.5)) tdmorefit &lt;- estimate(object = m1, observed = observed, regimen = regimen1) ## Warning in dnorm(ipred[i], obs[i], sd = sd[i], log = log): NaNs produced ## Warning in dnorm(ipred[i], obs[i], sd = sd[i], log = log): NaNs produced ## Warning in dnorm(ipred[i], obs[i], sd = sd[i], log = log): NaNs produced ## Warning in dnorm(ipred[i], obs[i], sd = sd[i], log = log): NaNs produced ## Warning in dnorm(ipred[i], obs[i], sd = sd[i], log = log): NaNs produced ## Warning in dnorm(ipred[i], obs[i], sd = sd[i], log = log): NaNs produced ## Warning in dnorm(ipred[i], obs[i], sd = sd[i], log = log): NaNs produced summary(tdmorefit) ## Call: ## estimate.default(object = m1, observed = observed, regimen = regimen1) ## Coef: ## EKA EV ECL ## 0.01972336 0.02310260 0.24016578 ## ## OFV: -6.51 (pop=2.1, pred=-8.61) ## ## Observations: ## TIME CONC ## 24 0.4 ## 48 0.5 ## ## Regimen: ## TIME AMT ## 0 150 ## 24 150 ## 48 150 ## 72 150 ## 96 150 ## 120 150 ## 144 150 ## ## Covariates: / ## ## Coefficients: ## name value (95% CI) se ## EKA 0.0197 (-1.04, 1.08) 0.541 ## EV 0.0231 (-0.9, 0.946) 0.471 ## ECL 0.2400 (-0.172, 0.652) 0.210 The above summary shows us how well the observed data was estimated. In particular, the objective function value (OFV) is shown. The higher this value, the better the fit. pop value is the population likelihood (it can be seen as how well the parameters fit the population PK model), pred value is the prediction likelihood (it can be seen as how well the parameters fit the observed data, knowing the population PK model). The summary also shows the coefficient values, as well as their 95% confidence interval (CI) and standard error (se). Because all ETA’s in this model have a standard deviation of sqrt(0.3)=0.547, we can deduce that the observed data only helped estimate ECL (standard errors of EKA and EV are too close from their original standard deviation). Predictions on the tdmorefit object can be done as follows (see also 6.3.2: data &lt;- predict(tdmorefit, newdata=data.frame(TIME=times, CONC=NA), se.fit=TRUE) Let’s now see what the virtual individual prediction tdmorefit looks like on a plot. ggplot(data, aes(x=TIME)) + geom_line(aes(color=&quot;Individual&quot;, y=CONC.median)) + geom_ribbon(aes(fill=&quot;Individual&quot;, ymin=CONC.lower, ymax=CONC.upper), fill=&quot;tomato1&quot;, alpha=0.10) + geom_line(aes(color=&quot;Population&quot;, y=CONC), data=data1) + geom_point(aes(y=CONC), data=observed) + scale_color_manual(values=c(&quot;tomato1&quot;, &quot;steelblue2&quot;)) 6.5 Dose recommendation 6.5.1 Calling the findDose method The findDose() method allows you to find the optimal virtual dose to use according to one or multiple targets. Its main arguments are: tdmorefit: the tdmorefit object regimen: the regimen (see section 6.2) doseRows (optional): which rows of the regimen to adapt when searching for a new dose, or NULL to take the last one interval (optional): which interval to search a dose in target: target value, as a data.frame The findDose() function contains a few more arguments, namely, to build a confidence interval on the returned dose using Monte-Carlo simulation. These are detailled in the documentation (try ?tdmore::findDose in the R console). Example 1: Reach the population trough concentration (first solution) Assume your virtual individual needs to reach a concentration of 0.75 after 1 week. A first solution is to find a daily dose that will achieve this. This can be done as follows: newRegimen &lt;- data.frame(TIME=0, AMT=NA, II=24, ADDL=7) recommendation1 &lt;- findDose( tdmorefit, regimen = newRegimen, interval = c(1, 1000), target = data.frame(TIME = 168, CONC = 0.75) ) summary(recommendation1) ## $dose ## [1] 224.7086 ## ## $regimen ## TIME AMT II ADDL ## 1 0 224.7086 24 7 A daily dose of 225mg is recommended for this specific virtual subject. Example 2: Reach the population trough concentration (second solution) Another possible way is to adapt the last dose only. This can be specified using the following regimen: newRegimen &lt;- data.frame(TIME=c(0,1,2,3,4,5,6)*24, AMT=c(150,150,150,150,150,150,NA)) recommendation2 &lt;- findDose( tdmorefit, regimen = newRegimen, interval = c(1, 1000), target = data.frame(TIME = 168, CONC = 0.75) ) summary(recommendation2) ## $dose ## [1] 241.3273 ## ## $regimen ## TIME AMT ## 1 0 150.0000 ## 2 24 150.0000 ## 3 48 150.0000 ## 4 72 150.0000 ## 5 96 150.0000 ## 6 120 150.0000 ## 7 144 241.3273 A last dose of 241mg is recommended for this specific virtual subject. Example 3: Ask for a confidence interval around the dose Use argument se.fit as follows: newRegimen &lt;- data.frame(TIME=c(0,1,2,3,4,5,6)*24, AMT=c(150,150,150,150,150,150,NA)) recommendation3 &lt;- findDose( tdmorefit, regimen = newRegimen, interval = c(1, 1000), target = data.frame(TIME = 168, CONC = 0.75), se.fit = T ) summary(recommendation3) ## $dose ## dose.median dose.lower dose.upper ## 249.8563 210.9439 316.8162 ## ## $regimen ## TIME AMT ## 1 0 150.0000 ## 2 24 150.0000 ## 3 48 150.0000 ## 4 72 150.0000 ## 5 96 150.0000 ## 6 120 150.0000 ## 7 144 249.8563 A 95% confidence interval is returned. 6.5.2 Visualise a recommendation Let’s compare the first and second examples. tdmorefit$regimen &lt;- recommendation1$regimen data1 &lt;- predict(tdmorefit, newdata=data.frame(TIME=times, CONC=NA), se.fit=F) data1$solution &lt;- factor(&quot;Solution 1&quot;) tdmorefit$regimen &lt;- recommendation2$regimen data2 &lt;- predict(tdmorefit, newdata=data.frame(TIME=times, CONC=NA), se.fit=F) data2$solution &lt;- factor(&quot;Solution 2&quot;) ggplot(rbind(data1, data2), aes(x=TIME, group=solution)) + geom_line(aes(color=solution, y=CONC)) + geom_hline(yintercept=0.75, linetype = &quot;dashed&quot;) + geom_point(aes(x=168, y=0.75), shape=1, size=3) Both solutions achieve the target in the virtual subject at the right time. 6.6 Plotting the intermediate steps 6.6.1 Plotting a tdmore object plot(m1, regimen=regimen1) 6.6.2 Plotting a tdmorefit object plot(tdmorefit) 6.6.3 Plotting a tdmorefit object with an adapted regimen newRegimen &lt;- data.frame(TIME=0, AMT=NA, II=24, ADDL=7) recommendation1 &lt;- findDose( tdmorefit, regimen = newRegimen, target = data.frame(TIME = 168, CONC = 0.75) ) plot(tdmorefit, regimen=recommendation1$regimen) 6.6.4 Plotting a tdmoreprofile object profile &lt;- profile(tdmorefit, maxpts=50, limits = list(ECL=c(0,0.7)), fix=c(EKA=0)) plot(profile) 6.7 Extending TDMore library(tidyverse) ## -- Attaching packages ------------------------------------------------------------------------- tidyverse 1.2.1 -- ## &lt;U+221A&gt; ggplot2 3.2.1 &lt;U+221A&gt; purrr 0.3.2 ## &lt;U+221A&gt; tibble 2.1.3 &lt;U+221A&gt; dplyr 0.8.3 ## &lt;U+221A&gt; tidyr 0.8.3 &lt;U+221A&gt; stringr 1.4.0 ## &lt;U+221A&gt; readr 1.3.1 &lt;U+221A&gt; forcats 0.4.0 ## -- Conflicts ---------------------------------------------------------------------------- tidyverse_conflicts() -- ## x dplyr::filter() masks stats::filter() ## x dplyr::lag() masks stats::lag() "],
["science.html", "Chapter 7 Science 7.1 Emperical Bayesian Estimation 7.2 Predictive performance 7.3 Predictive performance vs dose adaptation", " Chapter 7 Science This chapter reviews the main scientific basis behind TDMore 7.1 Emperical Bayesian Estimation TODO 7.2 Predictive performance 7.3 Predictive performance vs dose adaptation 7.3.1 Definitions Let us use a concrete example to evaluate whether predictive performance matches dose adaptation performance. Our model is defined as follows \\[ C = \\frac{D}{V} e^{-k(t-t_D)} \\] For multiple doses: \\[ C = \\sum\\frac{D_i}{V} e^{-k(t-t_{D_i})} \\] We define a very simple IIV model: \\(V = \\theta_V\\) and \\(k = \\theta_k (1+\\eta_k)\\). We will call this single \\(\\eta_k\\) simply \\(\\eta\\). Our residual error model is absolute: \\(C = Y + \\epsilon\\) 7.3.2 Simple curve fitting We could simply fit the curve. Assuming we have a single dose, and a single measured concentration: \\[ \\begin{aligned} C_0 &amp;= \\frac{D}{V} e^{-k(t_0-t_D)} \\\\ &amp;= \\frac{D}{V} e^{-\\theta_k(1+\\eta)(t_0-t_D)} \\\\ log(C_0) &amp;= log(D/V) -\\theta_k(1+\\eta)(t_0-t_D) \\\\ \\frac{log(C_0) - log(D/V)}{-\\theta_k(t_0-t_D)} &amp;= (1+\\eta) \\\\ \\frac{log(C_0) - log(D/V)}{-\\theta_k(t_0-t_D)} - 1 &amp;= \\eta \\\\ \\end{aligned} \\] However, this does not take into account that there might be residual error in the measurement. We should use bayesian curve fitting instead. 7.3.3 Empirical bayesian estimation Let’s define the likelihood for a given eta, assuming we have measured a concentration \\(C_0\\) at time \\(t_0\\): \\[ L = \\Phi(\\eta, 0, \\omega) * \\Phi(\\epsilon, 0, \\sigma) \\\\ with \\\\ C = Y + \\epsilon \\\\ \\epsilon = C-Y \\] Let us fill in the likelihood for a normal distribution \\(\\Phi(x|\\mu,\\sigma) = \\frac{1}{\\sqrt{2\\pi\\sigma^2}} e^{-\\frac{(x-\\mu)^2}{2\\sigma^2}}\\). We immediately use the Log-likelihood, and drop any terms that are not influenced by \\(\\eta\\). \\[ \\begin{aligned} LL &amp;= \\frac{\\eta^2}{2\\omega^2}+ \\frac{\\epsilon^2}{2\\sigma^2} \\\\ &amp;= \\frac{\\eta^2}{2\\omega^2}+ \\frac{\\epsilon^2}{2\\sigma^2} \\end{aligned} \\] We now find the optimum, which is at the point where the derivative is 0. \\[ \\frac{dLL}{d\\eta} = \\frac{2\\eta}{2\\omega^2}+ \\frac{2\\epsilon}{2\\sigma^2} \\frac{d\\epsilon}{d\\eta} \\] We calculate \\(\\frac{d\\epsilon^2}{d\\eta}\\): \\[ \\begin{aligned} \\frac{d\\epsilon}{d\\eta} &amp;= \\frac{d}{d\\eta} \\left( C-Y \\right) \\\\ &amp;= -\\frac{dY}{d\\eta} \\\\ &amp;= -\\frac{d}{d\\eta}\\left( \\frac{D}{V} e^{-\\theta_k(1+\\eta)(t-t_D)} \\right) \\\\ &amp;= -\\frac{D}{V} e^{-\\theta_k(1+\\eta)(t-t_D)} \\frac{d}{d\\eta}\\left( -\\theta_k(1+\\eta)(t-t_D) \\right) \\\\ &amp;= \\frac{D}{V} e^{-\\theta_k(1+\\eta)(t-t_D)} \\theta_k (t-t_D) \\] \\[ \\begin{aligned} \\frac{dLL}{d\\eta} &amp;= \\frac{2\\eta}{2\\omega^2}+ \\frac{2\\epsilon}{2\\sigma^2} \\frac{d\\epsilon}{d\\eta} \\\\ &amp;= \\frac{\\eta}{\\omega^2}+ \\frac{2\\epsilon}{2\\sigma^2} Y\\theta_k(t-tD) \\\\ &amp;= \\frac{\\eta}{\\omega^2}+ \\frac{1}{\\sigma^2} (C-Y)Y\\theta_k(t-tD) \\\\ &amp;= 0 \\ at\\ maximum \\end{aligned} \\] Even using the simplest possible model, the above equation does not have an analytical solution. Instead, we can explore how parameter estimates (and model predictions) change in function of different parameter values. We use a proportional error model and lognormal IIV, to be more realistic. TVk &lt;- 0.1 #/h V &lt;- 10 #L D &lt;- 10 #mg omega=0.40 #lognormal sigma=0.15 #proportional t=4 #4h post-dose predFun &lt;- function(eta) tdmore::pk1cptiv_(t=t, TIME=0, AMT=D, V=V, K=TVk*exp(eta)) * 1000 etaRange &lt;- seq(-4, 4, length.out=200)*omega ggplot(tibble(x=etaRange/omega, y=sapply(etaRange, predFun)) ) + geom_line(aes(x=x, y=y)) + annotate(&quot;point&quot;, size=2, x=0, y=predFun(0)) + labs(x=&quot;eta/omega&quot;, y=&quot;IPRED&quot;, title=&quot;Predicted concentration at one specific time-point&quot;, subtitle=&quot;Model is clearly non-linear&quot;) ggplot(tibble(x=etaRange/omega, y=sapply(etaRange, predFun)) ) + geom_line(aes(x=y, y=x)) + annotate(&quot;point&quot;, size=2, x=predFun(0), y=0) + labs(y=&quot;eta/omega&quot;, x=&quot;IPRED&quot;, title=&quot;To make the model predict high concentrations, you have to pull really hard at eta_k&quot;, subtitle=&quot;Logical; concentrations at t=4h can never exceed the initial concentration of 1000ng/mL!&quot;) ## CurveFit comes up with the theoretical eta, disregarding omega/sigma entirely curveFit &lt;- function(C) { fun &lt;- function(eta, C) { Y &lt;- predFun(eta) epsilon &lt;- Y/C -1 epsilon^2 } res &lt;- stats::optimize(fun, interval=c(-10*omega, 10*omega), C=C) res$minimum } testRange &lt;- seq(-4, 4, length.out=200)*omega sim &lt;- tibble::tibble( trueEta = testRange ) %&gt;% rowwise() %&gt;% mutate( C=predFun(trueEta), CurveFitEta = curveFit(C), CurveFitIPRED = predFun(CurveFitEta) ) ggplot(sim, aes(x=C, y=CurveFitIPRED)) + geom_point() + geom_abline() + labs(x=&quot;DV&quot;, y=&quot;IPRED&quot;, title=&quot;When curve fitting, IPRED perfectly matches points&quot;) ll &lt;- function(eta, C, pop=F, pred=F) { Y &lt;- predFun(eta) epsilon &lt;- Y/C -1 LLpop &lt;- dnorm(eta, 0, omega, log=TRUE) LLpred &lt;- dnorm(epsilon, 0, sigma, log=TRUE) if(pop) return(LLpop) if(pred) return(LLpred) return(-2*(LLpop + LLpred)) } etaFun &lt;- function(C) { res &lt;- stats::optimize(ll, interval=c(-10, 10)*omega, C=C) res$minimum } sim &lt;- sim %&gt;% mutate( ebeEta = etaFun(C), ebeIPRED = predFun(ebeEta) ) ggplot(sim, aes(y=C)) + geom_ribbon(aes(x=CurveFitIPRED, ymin=C-sigma*C, ymax=C+sigma*C), fill=&#39;green&#39;, alpha=0.1) + geom_line(aes(x=CurveFitIPRED, color=CurveFitEta/omega), lwd=1.3) + geom_point(aes(x=ebeIPRED, color=ebeEta/omega)) + scale_x_log10() + scale_y_log10() + scale_color_gradient2() + annotate(&quot;point&quot;, size=2, x=predFun(0), y=predFun(0)) + coord_flip() + labs(y=&quot;DV&quot;, x=&quot;IPRED&quot;, title=&quot;EBE estimates regress to the mean&quot;, subtitle=&quot;Green area shows residual error (+-1 sigma)&quot;, color=expression(frac(eta, omega)), caption=&quot;Curved line shows concentrations by EBE fitting. Dot corresponds to typical concentration&quot;) ggplot(sim, aes(x=C)) + geom_hline(yintercept=0, linetype=2) + geom_line(aes(y=CurveFitEta)) + geom_point(aes(y=ebeEta, color=ebeIPRED/C -1)) + annotate(&quot;point&quot;, size=2, x=predFun(0), y=0) + scale_color_gradient2() + # scale_x_log10() + labs(x=&quot;DV&quot;, y=expression(eta), color=expression(epsilon), title=&quot;EBE estimates regress to the mean&quot;, subtitle=&quot;Low concentrations require little adjustment on ETA to hit High concentrations are difficult and require massive ETA changes.&quot; ) Let’s analyse the behaviour for low concentrations and high concentrations llProfile &lt;- function(C, interval=c(-4, 4)*omega) { etaRange &lt;- seq(interval[1], interval[2], length.out=1000) tibble::tibble(eta=etaRange, OFV=sapply(etaRange, ll, C), LLpop=sapply(etaRange, ll, C, pop=T), LLpred=sapply(etaRange, ll, C, pred=T), etaHat=etaFun(C), OFVHat=ll(etaHat, C)) } CONCTest=c(250, 300, 500, 750, 900) tibble(C=CONCTest) %&gt;% group_by(C) %&gt;% group_modify(~llProfile(.y$C)) %&gt;% ggplot(aes(x=eta/omega)) + stat_function(fun=~dnorm(.x/omega, log=T)) + geom_line(aes(y=LLpop+LLpred, group=C, color=factor(C))) + geom_line(aes(y=LLpred, group=C, color=factor(C)), linetype=2) + geom_point(aes(x=etaHat/omega, y=OFVHat/-2)) + geom_segment(aes(x=etaHat/omega, y=OFVHat/-2, xend=stat(x), yend=Inf, color=factor(C))) + coord_cartesian(ylim=c(-4, 1)) + labs(x=&quot;Standardized ETA&quot;, y=&quot;Log-likelihood&quot;, color=&quot;Observed concentration&quot;, title=&quot;Overall log-likelihood is the sum of population LL and observation LL&quot;, subtitle=&quot;This pulls the estimate towards the mean\\nHow much depends on how certain the eta is compared to the RE model&quot;) ggplot(sim) + geom_point(aes(x=dnorm(ebeEta/omega, log=T), y=dnorm((ebeIPRED/C -1)/sigma, log=T), color=C )) + annotate(&quot;point&quot;, x=dnorm(0, log=T), y=dnorm(0, log=T)) + scale_color_gradient2(midpoint=predFun(0)) + labs(x=&quot;LL_pop&quot;, y=&quot;LL_pred&quot;, title=&quot;Do we pick an eta that nicely splits LL between LL_pop and LL_pred?&quot;, subtitle=&quot;For high concentrations, LL_pop is maintained and we accept a reduced LL_pred. For low concentrations, LL_pred is maintained and we accept a reduced LL_pop. Direct result of non-linear model.&quot; ) + coord_fixed() ggplot(sim, aes(x=ebeEta/omega)) + geom_point(aes(y=dnorm(ebeEta/omega), color=&quot;Phi_pop&quot;)) + geom_point(aes(y=dnorm((ebeIPRED/C -1)/sigma), color=&quot;Phi_pred&quot;)) + geom_point(aes(y=dnorm(ebeEta/omega)*dnorm((ebeIPRED/C -1)/sigma), color=&quot;Phi&quot;)) + labs(x=&quot;Omega-normalized ETA&quot;, y=&quot;Phi&quot;, color=&quot;&quot;, title=&quot;Plot of EBE fit results&quot;, subtitle= &quot;Low concentrations allow ETA to wander far, because the model can still fit them High concentrations keep an ETA close to mean, and LL_pred suffers.&quot;) "],
["validation.html", "Chapter 8 Validation 8.1 Development process 8.2 Standards: IEC 62304:2006 8.3 Validation requirements", " Chapter 8 Validation This section details the development process for TDMore. It also shows the validation (in a Computer Systems Validation GxP-sense, explicitly not in a clinical sense) that was performed. Finally, it hints at the requirements should you decide to develop this tool for in silico simulation and teaching into a in your dose adaptation software incorporating the TDMore engine on your own account (we explicitly discourage the use of the software provided for clinical purposes and deny any responsibility for it). 8.1 Development process TDMore is developed as an R package. The development team tries their best to adhere to international standards such as IEC 62304:2006. This ensures that the software is developed to the highest quality standards. New features are first described in a Github ticket. They are discussed between the development team and prioritized. The feature is then developed. The API is documented through Roxygen2, and its use is documented in a vignette or in the documentation book. Automated tests are written for every new feature. It is our intention to get code coverage of critical parts up to 100%. A continuous integration infrastructure is in place. GIT commit hooks ensure that all documentation is up-to-date at every commit. A push triggers automated testing in Travis. Furthermore, a Docker image is automatically built at every commit, and automated testing on the docker image is also performed. This ensures a stable environment to build on. 8.2 Standards: IEC 62304:2006 It should be stressed that TDMore is not a medical device. The software is for research and educational use only, and should never be directly used in patient care. The IEC 62304:2006 standard defines several requirements, some general and some specific to the development process. General requirements include Quality Management (ISO 13485), Risk Management (ISO 14971) and Software Safety Classification. These are not considered by the TDMore development team, as TDMore is not a medical device and clinical use is effectively discouraged by the developers. For Software Development, the standard requires Software development planning (Class A, B and C). This is implemented in TDMore in the Github repository issue tracker. Issues describe features or bugs that are developed. They are grouped together in milestones. The software plan is regularly updated, as can be shown by the github activity tracker. Screenshot of GitHub issues list However, this software is developed as open-source software. In that sense, it is not subject to clear planning. Instead, milestones are delivered as they come, and all standard software development processes apply to these releases. The standard requires Software requirements analysis. For TDMore, this consists of a thorough description of the intended feature in the ticket. In some cases, example code is added. Software architectural design is largely ad-hoc. There is no specific design role or stage. This should not be deemed problematic, as TDMore is not a large software with plenty of layers. Software detailed design can be considered an essential part of feature implementation. TDMore is not clinical user facing, but is built as an R package, to be consumed by developers and/or pharmacometricians for in silico work. APIs are carefully designed. Unit implementation and verification is done using RStudio and the GIT version control system. Peer review is used to verify all code committed. Automated tests are used to verify features function as expected. For now, no formal releases have been executed. It is our intent to release to CRAN regularly, starting september 2019. 8.3 Validation requirements It should be stressed that TDMore is not a medical device. The software is for research and educational use only, and should never be directly used in patient care without an extensive validation process, for which you and only you are responsible. Should you wish to build a dose adaptation tool, and include the TDMore mathematical engine, please note that we deny any responsibility and that any dose adaptation tool is classified as a Medical Device under MEDDEV July 2016. [page 20] Drug (e.g.: Chemotherapy) planning systems are intended to calculate the drug dosage to be administered to a specific patient and therefore are qualified as medical devices. Marketing such a tool for routine clinical use would indeed be subject to a CE-approval. A useful framework for the validation of such a tool could be found in FDA Guidance on Software as a Medical Device. Clinical Evaluation Process for SaMD As described in the figure, the validation process can be viewed in 3 parts: 8.3.1 Valid Clinical Association Is there a valid clinical association between the SaMD output and your SaMD’s targeted clinical condition? In the case of dose adaptation, you should show a valid association between the PK or PD target and actual clinical outcome. This can be shown on the basis of historical data, as long as the method of drug administration remains similar, and as long as it is causative. 8.3.2 Analytical Validation Does your SaMD correctly process input data to generate accurate, reliable, and precise output data? Although TDMore has been carefully validated to ensure valid results (within the limitations of the EBE or MPC estimation technique), that does not mean your model predicts individual outcomes accurately or precisely. A prospective evaluation should be performed, ideally on real data. This can be compared to physician performance in hitting the target. 8.3.3 Clinical Validation Does use of your SaMD’s accurate, reliable, and precise output data achieve your intended purpose in your target population in the context of clinical care? This requirement alludes to a prospective clinical trial. In this trial, you should show use of the software results in superior outcomes as compared to current practices. We strongly recommend to perform an in silico study first, at least to determine sample size. 8.3.4 Other requirements More streneous requirements may also be needed, including but not limited to: Server hosting, reliability and data privacy Robustness to data entry errors Robustness to outliers, e.g. heavily overweight patients Robustness to different assays used (e.g. LC/MS-MS vs immuno-assay) Protection against hackers or DoS attacks Maintenance and support In essence, if you want to build software geared towards clinical application based on TDMore, we deny any responsibility and suggest you to contact a lawyer, a Medical Device expert, and/or your local regulatory authority. "],
["vignettes.html", "Chapter 9 Vignettes 9.1 Running TDMore 9.2 Multiple endpoints 9.3 Example: Detecting non-adherence", " Chapter 9 Vignettes 9.1 Running TDMore Creating your model There are several ways telling TDMore what your model is. The easiest way is to provide the model in the form of a nxlmir model. The following example shows how a 2-compartment-PK model can be written. For the purpose of this demonstration, the ‘Meropenem’ PK model will be used. As Meropenem is given by injection into a vein, the absorption compartment is omitted. library(nlmixr) modelCode &lt;- function(){ ini({ TVV1 &lt;- 24.4; TVV2 &lt;- 7.01; TVQ &lt;- 4.97; TVCL &lt;- 9.87; ECL ~ 0.194 # This value corresponds to OMEGA_CL (44% SD) EV1 ~ 0.287 # This value corresponds to OMEGA_V1 (54% SD) EPS_PROP &lt;- 0.371 # Proportional error (37% SD) }) model({ CL &lt;- TVCL * exp(ECL) V1 &lt;- TVV1 * exp(EV1) V2 &lt;- TVV2 Q &lt;- TVQ K12 &lt;- Q/V1 K21 &lt;- Q/V2 d/dt(center) = - CL/V1 * center - K12*center + K21 * periph d/dt(periph) = K12*center - K21 * periph CONC = center / V1 CONC ~ prop(EPS_PROP) # Proportional error linked to the PK model }) } Once the model is created, a TDMore object can be instantiated as follows: library(tdmore) nlmixrUI &lt;- nlmixrUI(modelCode) tdmore &lt;- tdmore(nlmixrUI) The TDMore object is now ready for use. Predicting new data TDMore can be used to run simulations, based on the model defined in the previous step. For doing so, the regimen first needs to be specified. In the case of Meropenem, an 30-min injection is given into the central compartment every 8 hour. This can be written as follows: regimen &lt;- data.frame( TIME=c(0, 8, 16), # Every 8 hour and for 1 day, an injection is given AMT=c(1000, 1000, 1000), # 1g is administered RATE=c(1000, 1000, 1000)/0.5 # 30-minute infusion (rate=dose/infusion time) ) Let’s now simulate the population PK model for 1 day. This can be done using the TDMore predict() function. A dataframe with all the times to predict (and respective NA concentration) is given to the ‘newdata’ argument. Field ‘se’ is set to true, it tells TDMore we are interested to simulate the model with residual variability. data &lt;- predict( object = tdmore, newdata = data.frame(TIME = seq(0, 24, by = 0.5), CONC = NA), regimen = regimen, se = TRUE ) library(ggplot2) ggplot(data, aes(x=TIME, y=CONC)) + geom_ribbon(aes(fill=&quot;Population&quot;, ymin=CONC.lower, ymax=CONC.upper), fill=&quot;steelblue2&quot;, alpha=0.15) + geom_line(aes(color=&quot;Population&quot;), data=data) + scale_color_manual(values=c(&quot;steelblue2&quot;)) + scale_y_log10() The plot above shows the median of the population (typical profile) and its 95% confidence interval. The range of the confidence interval can be changed using the argument ‘level’. Estimating individual parameters This section will show you how the individual parameters can be estimated, based on some observed data. Let’s first estimate the parameters of a typical individual. This is achieved by calling the estimate() function. pred &lt;- estimate(tdmore, regimen = regimen) coef(pred) ## ECL EV1 ## 0 0 Both eta’s ECL and EV1 have been estimated to 0. This is not surprising, as zero eta’s best describe the population average. We can also look at the uncertainty on these estimates. vcov(pred) ## ECL EV1 ## ECL 1.940000e-01 1.090438e-13 ## EV1 1.090438e-13 2.870000e-01 This uncertainty is equal to the population inter-individual variability (OMEGA matrix). Now, let’s assume blood samples have been collected for a subject X at different times. For example, blood samples were collected at times 9h and 16h on the first day. This can be translated in TDMore as follows (note that the concentrations are purely fictive): observed &lt;- data.frame(TIME=c(9, 15), CONC=c(30, 2)) We can ask TDMore to re-estimate the parameters for this specific individual: ipred &lt;- estimate(tdmore, observed = observed, regimen = regimen) coef(ipred) ## ECL EV1 ## 0.2597598 -0.1320256 Eta’s obtained by calling ‘coef’ on pred maximise altogether the likelihood for this specific subject. The variance-covariance matrix shows the uncertainty of the individual estimates, and their correlation. vcov(ipred) ## ECL EV1 ## ECL 0.03154125 0.04680262 ## EV1 0.04680262 0.12759879 Predictions for the population (pred) and this specific subject (ipred) can be compared using the following snippet: data &lt;- predict(ipred, newdata=data.frame(TIME=seq(0, 24, 0.1), CONC=NA), se=TRUE) ggplot(data, aes(x=TIME)) + geom_line(aes(color=&quot;Individual&quot;, y=CONC.median)) + geom_ribbon(aes(fill=&quot;Individual&quot;, ymin=CONC.lower, ymax=CONC.upper), fill=&quot;tomato1&quot;, alpha=0.10) + geom_line(aes(color=&quot;Population&quot;, y=CONC), data=predict(pred, newdata=seq(0, 24, 0.1))) + geom_point(aes(y=CONC), data=observed) + scale_color_manual(values=c(&quot;tomato1&quot;, &quot;steelblue2&quot;)) + scale_y_log10() Ipred and pred are shown respectively in red and blue. A 95% confidence interval has been added around the ipred prediction. Note that the default TDMore plotting function can also be used to obtain the exact same plot in a single line of code: plot(ipred, newdata=data.frame(TIME=seq(0.1, 24, by=0.1), CONC=NA)) + scale_y_log10() Finding the right dose to give A very interesting feature in TDMore is the possibility to ask the framework the next dose to be given knowing all the previous observations that were collected and some known end-points. For example, assume we still collected the same two observations on the first day, we would like to find the best first dose to be given on the second day. We would like to reach the trough concentration of 3.10 mg/L as much as possible. This can be expressed, as follows: newRegimen &lt;- data.frame( TIME=c(0, 8, 16, 24), # A fourth dose on the second day is added AMT=c(1000, 1000, 1000, NA), # Adding an unknown dose on the second day RATE=c(1000, 1000, 1000, 1000)/0.5 # 30-minute infusion (rate=dose/infusion time) ) recommendation &lt;- findDose( ipred, regimen = newRegimen, interval = c(100, 5000), target = data.frame(TIME = 32, CONC = 8) ) summary(recommendation) ## $dose ## [1] 4540.072 ## ## $regimen ## TIME AMT RATE ## 1 0 1000.000 2000 ## 2 8 1000.000 2000 ## 3 16 1000.000 2000 ## 4 24 4540.072 2000 The result of the findDose() routine is shown above. It tells us that XXX mg (approximately) is the recommended starting dose on the second day. The following code helps up verify this visually. # Recommended regimen for individual can be directly accessed from the recommendation object ipredRecommendedRegimen &lt;- recommendation$regimen # Population regimen can be updated using the &#39;updateRegimen&#39; method, a 4th dose of 1000 is used predUpdatedRegimen &lt;- updateRegimen(regimen = newRegimen, newDose = 4500) print(predUpdatedRegimen) # Check pred regimen ## TIME AMT RATE ## 1 0 1000 2000 ## 2 8 1000 2000 ## 3 16 1000 2000 ## 4 24 4500 2000 ipred &lt;- estimate(tdmore, observed = observed, regimen = ipredRecommendedRegimen) pred &lt;- estimate(tdmore, regimen = predUpdatedRegimen) plot(ipred, newdata=seq(0, 32, by=0.1)) + geom_hline(yintercept=8) + scale_y_log10() The plot above demonstrates that the individual is reaching the trough concentration quite well after the first administration on the second day. 9.1.1 Code appendix set.seed(0) library(nlmixr) modelCode &lt;- function(){ ini({ TVV1 &lt;- 24.4; TVV2 &lt;- 7.01; TVQ &lt;- 4.97; TVCL &lt;- 9.87; ECL ~ 0.194 # This value corresponds to OMEGA_CL (44% SD) EV1 ~ 0.287 # This value corresponds to OMEGA_V1 (54% SD) EPS_PROP &lt;- 0.371 # Proportional error (37% SD) }) model({ CL &lt;- TVCL * exp(ECL) V1 &lt;- TVV1 * exp(EV1) V2 &lt;- TVV2 Q &lt;- TVQ K12 &lt;- Q/V1 K21 &lt;- Q/V2 d/dt(center) = - CL/V1 * center - K12*center + K21 * periph d/dt(periph) = K12*center - K21 * periph CONC = center / V1 CONC ~ prop(EPS_PROP) # Proportional error linked to the PK model }) } library(tdmore) nlmixrUI &lt;- nlmixrUI(modelCode) tdmore &lt;- tdmore(nlmixrUI) regimen &lt;- data.frame( TIME=c(0, 8, 16), # Every 8 hour and for 1 day, an injection is given AMT=c(1000, 1000, 1000), # 1g is administered RATE=c(1000, 1000, 1000)/0.5 # 30-minute infusion (rate=dose/infusion time) ) data &lt;- predict( object = tdmore, newdata = data.frame(TIME = seq(0, 24, by = 0.5), CONC = NA), regimen = regimen, se = TRUE ) library(ggplot2) ggplot(data, aes(x=TIME, y=CONC)) + geom_ribbon(aes(fill=&quot;Population&quot;, ymin=CONC.lower, ymax=CONC.upper), fill=&quot;steelblue2&quot;, alpha=0.15) + geom_line(aes(color=&quot;Population&quot;), data=data) + scale_color_manual(values=c(&quot;steelblue2&quot;)) + scale_y_log10() pred &lt;- estimate(tdmore, regimen = regimen) coef(pred) vcov(pred) observed &lt;- data.frame(TIME=c(9, 15), CONC=c(30, 2)) ipred &lt;- estimate(tdmore, observed = observed, regimen = regimen) coef(ipred) vcov(ipred) data &lt;- predict(ipred, newdata=data.frame(TIME=seq(0, 24, 0.1), CONC=NA), se=TRUE) ggplot(data, aes(x=TIME)) + geom_line(aes(color=&quot;Individual&quot;, y=CONC.median)) + geom_ribbon(aes(fill=&quot;Individual&quot;, ymin=CONC.lower, ymax=CONC.upper), fill=&quot;tomato1&quot;, alpha=0.10) + geom_line(aes(color=&quot;Population&quot;, y=CONC), data=predict(pred, newdata=seq(0, 24, 0.1))) + geom_point(aes(y=CONC), data=observed) + scale_color_manual(values=c(&quot;tomato1&quot;, &quot;steelblue2&quot;)) + scale_y_log10() plot(ipred, newdata=data.frame(TIME=seq(0.1, 24, by=0.1), CONC=NA)) + scale_y_log10() newRegimen &lt;- data.frame( TIME=c(0, 8, 16, 24), # A fourth dose on the second day is added AMT=c(1000, 1000, 1000, NA), # Adding an unknown dose on the second day RATE=c(1000, 1000, 1000, 1000)/0.5 # 30-minute infusion (rate=dose/infusion time) ) recommendation &lt;- findDose( ipred, regimen = newRegimen, interval = c(100, 5000), target = data.frame(TIME = 32, CONC = 8) ) summary(recommendation) # Recommended regimen for individual can be directly accessed from the recommendation object ipredRecommendedRegimen &lt;- recommendation$regimen # Population regimen can be updated using the &#39;updateRegimen&#39; method, a 4th dose of 1000 is used predUpdatedRegimen &lt;- updateRegimen(regimen = newRegimen, newDose = 4500) print(predUpdatedRegimen) # Check pred regimen ipred &lt;- estimate(tdmore, observed = observed, regimen = ipredRecommendedRegimen) pred &lt;- estimate(tdmore, regimen = predUpdatedRegimen) plot(ipred, newdata=seq(0, 32, by=0.1)) + geom_hline(yintercept=8) + scale_y_log10() 9.2 Multiple endpoints Writing and testing the PK model In this vignette, we will learn how TDMore can deal with multiple endpoints. The PK/PD models chosen to illustrate this section are based on the following paper: “Population PK/PD modeling of Sunitinib by dosing schedule in patients with advanced renal cell carcinoma or gastrointestinal stromal tumor.”. Let’s start writing the Sunitinib PK model. library(nlmixr) modelCode &lt;- function(){ ini({ TVCL &lt;- 34.1 TVVc &lt;- 2700 TVKa &lt;- 0.126 TVVp &lt;- 774 TVQ &lt;- 0.688 ECL ~ 0.060516 # 24.6% EVc ~ 0.052900 # 23.0% EKa ~ 2.755600 # 166% EPS_Prop &lt;- 0.417 }) model({ CL &lt;- TVCL * exp(ECL) Vc &lt;- TVVc * exp(EVc) Vp &lt;- TVVp Q &lt;- TVQ K12 &lt;- Q/Vc K21 &lt;- Q/Vp Ke &lt;- CL/Vc Ka &lt;- TVKa*exp(EKa) d/dt(depot) = -Ka*depot d/dt(center) = Ka*depot - Ke*center - K12*center + K21*periph d/dt(periph) = K12*center - K21*periph CONC = center/Vc CONC ~ prop(EPS_Prop) }) } The TDMore object is instantiated as follows: library(tdmore) nlmixrModel &lt;- nlmixrUI(modelCode) m1 &lt;- tdmore(nlmixrModel) A basic regimen can be created to test that the model is running properly. The standard regimen of Sunitinib is 50mg daily for 4 weeks. regimen &lt;- data.frame( TIME=0, # First dose time: t=0h AMT=50, # Dose amount: 50 mg II=24, # Dose interval: 24h ADDL=4*7-1 # Additional doses: 4 weeks ) times &lt;- seq(0, 6*7*24) # Observation times This regimen can be plotted using the default TDMore plotting function. It shows the typical value of the population and the between-subject variability (95% confidence interval). plot(m1, regimen, newdata=times) Adding a PD model Suppose we received a full blood workup: Sunitinib concentration, Alanine aminotransferase (ALT), Aspartate aminotransferase (AST), Absolute neutrophil count (ANC), Platelet count (PC) and Lymphocyte count (LC). We also measured the subject’s diastolic blood pressure (DBP). We can create a single model to predict all of these aspects. In the example below, we will focus on ALT and AST. Please note the mandatory ‘|’ nlmixr syntax used to describe the residual variability of different endpoints. modelCode &lt;- function(){ ini({ # PK model sunitinib TVCL &lt;- 34.1 TVVc &lt;- 2700 TVKa &lt;- 0.126 TVVp &lt;- 774 TVQ &lt;- 0.688 ECL ~ 0.060516 # 24.6% EVc ~ 0.052900 # 23.0% EKa ~ 2.755600 # 166% EPS_Prop &lt;- 0.417 # Proportional error 1 (related to CONC) # PD model ALT TVBASE_AST &lt;- 21.5 TVKout_AST &lt;- 0.0142 TVKpd_AST &lt;- 0.00572 EPS_Prop_AST = 0.257 #25.7% # PD model AST TVBASE_ALT &lt;- 21.2 TVKout_ALT &lt;- 0.00916 TVKpd_ALT &lt;- 0.00401 EPS_Prop_ALT = 0.373 #37.3% # We assume 0.5 correlations in IIV, even though they are not reported in the original paper EBASE_AST + EBASE_ALT ~ c(0.101124, 0.05028021, 0.164025) # 31.8% #40.5% EKout_AST + EKout_ALT ~ c(1.440000, 0.1897367, 1.638400)#120% #128% EKpd_AST + EKpd_ALT ~ c(0.114244, 0.05344249, 0.324900) #33.8% #57.0% }) model({ # PK parameters CL &lt;- TVCL * exp(ECL) Vc &lt;- TVVc * exp(EVc) Vp &lt;- TVVp Q &lt;- TVQ K12 &lt;- Q/Vc K21 &lt;- Q/Vp Ke &lt;- CL/Vc Ka &lt;- TVKa*exp(EKa) # AST parameters BASE_AST &lt;- TVBASE_AST * exp(EBASE_AST) Kout_AST &lt;- TVKout_AST * exp(EKout_AST) Kpd_AST &lt;- TVKpd_AST * exp(EKpd_AST) #mL/ng Kin_AST &lt;- Kout_AST * BASE_AST # ALT parameters BASE_ALT &lt;- TVBASE_ALT * exp(EBASE_ALT) Kout_ALT &lt;- TVKout_ALT * exp(EKout_ALT) Kpd_ALT &lt;- TVKpd_ALT * exp(EKpd_ALT) #mL/ng Kin_ALT &lt;- Kout_ALT * BASE_ALT # PK model d/dt(depot) = -Ka*depot d/dt(center) = Ka*depot - Ke*center - K12*center + K21*periph d/dt(periph) = K12*center - K21*periph CONC = center/Vc * 1000 #ng/mL # AST model AST(0) = BASE_AST d/dt(AST) = Kin_AST - Kout_AST*AST*(1-Kpd_AST*CONC) # ALT model ALT(0) = BASE_ALT d/dt(ALT) = Kin_ALT - Kout_ALT*ALT*(1-Kpd_ALT*CONC) # Residual error models CONC ~ prop(EPS_Prop) | center # Define error model 1 AST ~ prop(EPS_Prop_AST) | AST # error model 2 ALT ~ prop(EPS_Prop_ALT) | ALT # error model 3 }) } nlmixrModel &lt;- nlmixrUI(modelCode) m2 &lt;- tdmore(nlmixrModel, maxsteps=1E3*500) Let’s now have a look at the evolution of these safety signals over time. To have a good overview, we will observe ALT/AST for 4 weeks treatment. The default plot shows once again the typical value and the between-subject variability (95% CI). regimen &lt;- data.frame( TIME=0, AMT=50, II=24, ADDL=4*7 ) times &lt;- seq(0, 6*7*24, by=1) plot(m2, regimen, newdata=data.frame(TIME=times, CONC=NA)) plot(m2, regimen, newdata=data.frame(TIME=times, ALT=NA)) plot(m2, regimen, newdata=data.frame(TIME=times, AST=NA)) Estimating individual parameters We get the values for ALT/AST for a specific individual. These are quite high! observed &lt;- data.frame( TIME=c(0, 2,3,4)*7*24, CONC=NA, ALT=c(21, 40, 42, 43), AST=c(21, 45, 47, 49)) ipred &lt;- estimate(m2, observed = observed, regimen = regimen) plot(ipred, newdata=data.frame(TIME=times, CONC=NA)) plot(ipred, newdata=data.frame(TIME=times, ALT=NA)) plot(ipred, newdata=data.frame(TIME=times, AST=NA)) Based on only ALT/AST values, we managed to define the PK inter-individual variability a little better. Indeed, these high ALT/AST values can be best explained through a combination of high sensitivity (EKpd), and a lower clearance (ECL) of the drug. coef(ipred) ## ECL EVc EKa EBASE_AST EBASE_ALT EKout_AST ## -0.13927141 -0.01279161 0.02257760 0.03233717 0.04497158 0.22456560 ## EKout_ALT EKpd_AST EKpd_ALT ## 0.22778905 0.24279322 0.37291944 coef(ipred) / sqrt(diag(m2$omega)) ## ECL EVc EKa EBASE_AST EBASE_ALT EKout_AST ## -0.56614395 -0.05561569 0.01360096 0.10168920 0.11104095 0.18713800 ## EKout_ALT EKpd_AST EKpd_ALT ## 0.17796020 0.71832312 0.65424462 9.2.1 Code appendix set.seed(0) library(nlmixr) modelCode &lt;- function(){ ini({ TVV1 &lt;- 24.4; TVV2 &lt;- 7.01; TVQ &lt;- 4.97; TVCL &lt;- 9.87; ECL ~ 0.194 # This value corresponds to OMEGA_CL (44% SD) EV1 ~ 0.287 # This value corresponds to OMEGA_V1 (54% SD) EPS_PROP &lt;- 0.371 # Proportional error (37% SD) }) model({ CL &lt;- TVCL * exp(ECL) V1 &lt;- TVV1 * exp(EV1) V2 &lt;- TVV2 Q &lt;- TVQ K12 &lt;- Q/V1 K21 &lt;- Q/V2 d/dt(center) = - CL/V1 * center - K12*center + K21 * periph d/dt(periph) = K12*center - K21 * periph CONC = center / V1 CONC ~ prop(EPS_PROP) # Proportional error linked to the PK model }) } library(tdmore) nlmixrUI &lt;- nlmixrUI(modelCode) tdmore &lt;- tdmore(nlmixrUI) regimen &lt;- data.frame( TIME=c(0, 8, 16), # Every 8 hour and for 1 day, an injection is given AMT=c(1000, 1000, 1000), # 1g is administered RATE=c(1000, 1000, 1000)/0.5 # 30-minute infusion (rate=dose/infusion time) ) data &lt;- predict( object = tdmore, newdata = data.frame(TIME = seq(0, 24, by = 0.5), CONC = NA), regimen = regimen, se = TRUE ) library(ggplot2) ggplot(data, aes(x=TIME, y=CONC)) + geom_ribbon(aes(fill=&quot;Population&quot;, ymin=CONC.lower, ymax=CONC.upper), fill=&quot;steelblue2&quot;, alpha=0.15) + geom_line(aes(color=&quot;Population&quot;), data=data) + scale_color_manual(values=c(&quot;steelblue2&quot;)) + scale_y_log10() pred &lt;- estimate(tdmore, regimen = regimen) coef(pred) vcov(pred) observed &lt;- data.frame(TIME=c(9, 15), CONC=c(30, 2)) ipred &lt;- estimate(tdmore, observed = observed, regimen = regimen) coef(ipred) vcov(ipred) data &lt;- predict(ipred, newdata=data.frame(TIME=seq(0, 24, 0.1), CONC=NA), se=TRUE) ggplot(data, aes(x=TIME)) + geom_line(aes(color=&quot;Individual&quot;, y=CONC.median)) + geom_ribbon(aes(fill=&quot;Individual&quot;, ymin=CONC.lower, ymax=CONC.upper), fill=&quot;tomato1&quot;, alpha=0.10) + geom_line(aes(color=&quot;Population&quot;, y=CONC), data=predict(pred, newdata=seq(0, 24, 0.1))) + geom_point(aes(y=CONC), data=observed) + scale_color_manual(values=c(&quot;tomato1&quot;, &quot;steelblue2&quot;)) + scale_y_log10() plot(ipred, newdata=data.frame(TIME=seq(0.1, 24, by=0.1), CONC=NA)) + scale_y_log10() newRegimen &lt;- data.frame( TIME=c(0, 8, 16, 24), # A fourth dose on the second day is added AMT=c(1000, 1000, 1000, NA), # Adding an unknown dose on the second day RATE=c(1000, 1000, 1000, 1000)/0.5 # 30-minute infusion (rate=dose/infusion time) ) recommendation &lt;- findDose( ipred, regimen = newRegimen, interval = c(100, 5000), target = data.frame(TIME = 32, CONC = 8) ) summary(recommendation) # Recommended regimen for individual can be directly accessed from the recommendation object ipredRecommendedRegimen &lt;- recommendation$regimen # Population regimen can be updated using the &#39;updateRegimen&#39; method, a 4th dose of 1000 is used predUpdatedRegimen &lt;- updateRegimen(regimen = newRegimen, newDose = 4500) print(predUpdatedRegimen) # Check pred regimen ipred &lt;- estimate(tdmore, observed = observed, regimen = ipredRecommendedRegimen) pred &lt;- estimate(tdmore, regimen = predUpdatedRegimen) plot(ipred, newdata=seq(0, 32, by=0.1)) + geom_hline(yintercept=8) + scale_y_log10() set.seed(0) library(nlmixr) modelCode &lt;- function(){ ini({ TVCL &lt;- 34.1 TVVc &lt;- 2700 TVKa &lt;- 0.126 TVVp &lt;- 774 TVQ &lt;- 0.688 ECL ~ 0.060516 # 24.6% EVc ~ 0.052900 # 23.0% EKa ~ 2.755600 # 166% EPS_Prop &lt;- 0.417 }) model({ CL &lt;- TVCL * exp(ECL) Vc &lt;- TVVc * exp(EVc) Vp &lt;- TVVp Q &lt;- TVQ K12 &lt;- Q/Vc K21 &lt;- Q/Vp Ke &lt;- CL/Vc Ka &lt;- TVKa*exp(EKa) d/dt(depot) = -Ka*depot d/dt(center) = Ka*depot - Ke*center - K12*center + K21*periph d/dt(periph) = K12*center - K21*periph CONC = center/Vc CONC ~ prop(EPS_Prop) }) } library(tdmore) nlmixrModel &lt;- nlmixrUI(modelCode) m1 &lt;- tdmore(nlmixrModel) regimen &lt;- data.frame( TIME=0, # First dose time: t=0h AMT=50, # Dose amount: 50 mg II=24, # Dose interval: 24h ADDL=4*7-1 # Additional doses: 4 weeks ) times &lt;- seq(0, 6*7*24) # Observation times plot(m1, regimen, newdata=times) modelCode &lt;- function(){ ini({ # PK model sunitinib TVCL &lt;- 34.1 TVVc &lt;- 2700 TVKa &lt;- 0.126 TVVp &lt;- 774 TVQ &lt;- 0.688 ECL ~ 0.060516 # 24.6% EVc ~ 0.052900 # 23.0% EKa ~ 2.755600 # 166% EPS_Prop &lt;- 0.417 # Proportional error 1 (related to CONC) # PD model ALT TVBASE_AST &lt;- 21.5 TVKout_AST &lt;- 0.0142 TVKpd_AST &lt;- 0.00572 EPS_Prop_AST = 0.257 #25.7% # PD model AST TVBASE_ALT &lt;- 21.2 TVKout_ALT &lt;- 0.00916 TVKpd_ALT &lt;- 0.00401 EPS_Prop_ALT = 0.373 #37.3% # We assume 0.5 correlations in IIV, even though they are not reported in the original paper EBASE_AST + EBASE_ALT ~ c(0.101124, 0.05028021, 0.164025) # 31.8% #40.5% EKout_AST + EKout_ALT ~ c(1.440000, 0.1897367, 1.638400)#120% #128% EKpd_AST + EKpd_ALT ~ c(0.114244, 0.05344249, 0.324900) #33.8% #57.0% }) model({ # PK parameters CL &lt;- TVCL * exp(ECL) Vc &lt;- TVVc * exp(EVc) Vp &lt;- TVVp Q &lt;- TVQ K12 &lt;- Q/Vc K21 &lt;- Q/Vp Ke &lt;- CL/Vc Ka &lt;- TVKa*exp(EKa) # AST parameters BASE_AST &lt;- TVBASE_AST * exp(EBASE_AST) Kout_AST &lt;- TVKout_AST * exp(EKout_AST) Kpd_AST &lt;- TVKpd_AST * exp(EKpd_AST) #mL/ng Kin_AST &lt;- Kout_AST * BASE_AST # ALT parameters BASE_ALT &lt;- TVBASE_ALT * exp(EBASE_ALT) Kout_ALT &lt;- TVKout_ALT * exp(EKout_ALT) Kpd_ALT &lt;- TVKpd_ALT * exp(EKpd_ALT) #mL/ng Kin_ALT &lt;- Kout_ALT * BASE_ALT # PK model d/dt(depot) = -Ka*depot d/dt(center) = Ka*depot - Ke*center - K12*center + K21*periph d/dt(periph) = K12*center - K21*periph CONC = center/Vc * 1000 #ng/mL # AST model AST(0) = BASE_AST d/dt(AST) = Kin_AST - Kout_AST*AST*(1-Kpd_AST*CONC) # ALT model ALT(0) = BASE_ALT d/dt(ALT) = Kin_ALT - Kout_ALT*ALT*(1-Kpd_ALT*CONC) # Residual error models CONC ~ prop(EPS_Prop) | center # Define error model 1 AST ~ prop(EPS_Prop_AST) | AST # error model 2 ALT ~ prop(EPS_Prop_ALT) | ALT # error model 3 }) } nlmixrModel &lt;- nlmixrUI(modelCode) m2 &lt;- tdmore(nlmixrModel, maxsteps=1E3*500) regimen &lt;- data.frame( TIME=0, AMT=50, II=24, ADDL=4*7 ) times &lt;- seq(0, 6*7*24, by=1) plot(m2, regimen, newdata=data.frame(TIME=times, CONC=NA)) plot(m2, regimen, newdata=data.frame(TIME=times, ALT=NA)) plot(m2, regimen, newdata=data.frame(TIME=times, AST=NA)) observed &lt;- data.frame( TIME=c(0, 2,3,4)*7*24, CONC=NA, ALT=c(21, 40, 42, 43), AST=c(21, 45, 47, 49)) ipred &lt;- estimate(m2, observed = observed, regimen = regimen) plot(ipred, newdata=data.frame(TIME=times, CONC=NA)) plot(ipred, newdata=data.frame(TIME=times, ALT=NA)) plot(ipred, newdata=data.frame(TIME=times, AST=NA)) coef(ipred) coef(ipred) / sqrt(diag(m2$omega)) 9.3 Example: Detecting non-adherence About this example Non-compliance is an important issue endangering the effectiveness of treatments. In COPD, it is estimated that there is a non-compliance of more than 98% for inhaled treatments. In this example, we use TDMore to compare the systemic concentrations of inhaled fluticasone propionate with the population predictions. We show that TDMore can be used to detect severe non-adherence, and to propose corrective action. The model Model taken from literature: Soulele, K., et al. “Population pharmacokinetics of fluticasone propionate/salmeterol using two different dry powder inhalers.” European Journal of Pharmaceutical Sciences 80 (2015): 33-42. library(nlmixr) modelCode &lt;- function(){ ini({ TVKa &lt;- 3.87 TVCL &lt;- 659 #L/h TVV1 &lt;- 56900 #L TVV2 &lt;- 5550 #L TVQ &lt;- 259 #L/h EKa ~ 0.04507129 #0.2123**2 ECL ~ 0.1535856 #0.3919**2 EV1 ~ 0.09223369 #0.3037**2 EV2 ~ 0.208301 #0.4564**2 EQ ~ 0.1015697# 0.3187**2 EPS_ADD &lt;- 1.91 # EPS_PROP &lt;- 0.117 }) model({ Ka &lt;- TVKa * exp(EKa) CL &lt;- TVCL * exp(ECL) V1 &lt;- TVV1 * exp(EV1) V2 &lt;- TVV2 * exp(EV2) Q &lt;- TVQ * exp(EQ) K12 &lt;- Q/V1 K21 &lt;- Q/V2 d/dt(center) = - CL/V1 * center - K12*center + K21 * periph d/dt(periph) = K12*center - K21 * periph CONC = center / V1 * 1000 CONC ~ prop(EPS_PROP) + add(EPS_ADD) }) } nlmixrModel &lt;- nlmixrUI(modelCode) library(tdmore) m1 &lt;- tdmore(nlmixrModel) We now define the treatment regimen regimen &lt;- data.frame( TIME=seq(0, by=24, length.out=30), AMT=500 # 500ug standard dose ) adhering &lt;- predict(m1, regimen=regimen, newdata=seq(0, 30*24)) actual &lt;- data.frame( TIME=seq(0, by=24, length.out=30), AMT=500*sample(c(0,1), 30, replace=TRUE) # probability of 50% to not take the dose ) nonAdhering &lt;- predict(m1, regimen=actual, newdata=seq(0, 30*24)) library(ggplot2) pred &lt;- estimate(m1, regimen=regimen) ggplot(mapping=aes(x=TIME, y=CONC)) + geom_line(aes(color=&quot;Adhering&quot;), data=adhering) + geom_line(aes(color=&quot;Non-adhering&quot;), data=nonAdhering) Is the subject taking his/her medication? We can now take a serum sample and evaluate if there is non-adherence. # Take a blood sample observed &lt;- predict(m1, regimen=actual, newdata=data.frame(TIME=30*24+c(-16, 0), CONC=NA)) observed TIME CONC 704 6.16 720 5.19 # We estimate individual parameters # as if the virtual subject took his medication # properly ipred &lt;- estimate(m1, observed, regimen) coef(ipred) ## EKa ECL EV1 EV2 EQ ## 0.0000000000 1.2384564464 0.0233203384 -0.0004283304 0.0022528398 ggplot(mapping=aes(x=TIME, y=CONC)) + geom_line(aes(color=&quot;Reality&quot;), data=nonAdhering) + geom_point(data=observed) + geom_line(aes(color=&quot;Population&quot;), data=adhering) + # geom_ribbon(aes(fill=&quot;Population&quot;, ymin=CONC.lower, ymax=CONC.upper), # data=predict(m1, regimen=regimen, newdata=data.frame(TIME=seq(0, 30*24), CONC=NA), se.fit=TRUE), alpha=0.1) + geom_line(aes(color=&quot;Prediction&quot;), data=predict(ipred, regimen=regimen, newdata=data.frame(TIME=seq(0, 30*24), CONC=NA))) standardDeviations &lt;- coef(ipred) / sqrt(diag(m1$omega)) standardDeviations ## EKa ECL EV1 EV2 EQ ## 0.0000000000 3.1601339289 0.0767874167 -0.0009384978 0.0070688412 i &lt;- which(pnorm(abs(standardDeviations)) &gt; 0.975) if(length(i) &gt; 0) { cat(&quot;This subject has unlikely (outside 95% CI) parameter estimates for &quot;, names(i),&quot;. There may be a treatment adherence issue.&quot;) } ## This subject has unlikely (outside 95% CI) parameter estimates for ECL . There may be a treatment adherence issue. 9.3.1 Code appendix set.seed(0) library(nlmixr) modelCode &lt;- function(){ ini({ TVV1 &lt;- 24.4; TVV2 &lt;- 7.01; TVQ &lt;- 4.97; TVCL &lt;- 9.87; ECL ~ 0.194 # This value corresponds to OMEGA_CL (44% SD) EV1 ~ 0.287 # This value corresponds to OMEGA_V1 (54% SD) EPS_PROP &lt;- 0.371 # Proportional error (37% SD) }) model({ CL &lt;- TVCL * exp(ECL) V1 &lt;- TVV1 * exp(EV1) V2 &lt;- TVV2 Q &lt;- TVQ K12 &lt;- Q/V1 K21 &lt;- Q/V2 d/dt(center) = - CL/V1 * center - K12*center + K21 * periph d/dt(periph) = K12*center - K21 * periph CONC = center / V1 CONC ~ prop(EPS_PROP) # Proportional error linked to the PK model }) } library(tdmore) nlmixrUI &lt;- nlmixrUI(modelCode) tdmore &lt;- tdmore(nlmixrUI) regimen &lt;- data.frame( TIME=c(0, 8, 16), # Every 8 hour and for 1 day, an injection is given AMT=c(1000, 1000, 1000), # 1g is administered RATE=c(1000, 1000, 1000)/0.5 # 30-minute infusion (rate=dose/infusion time) ) data &lt;- predict( object = tdmore, newdata = data.frame(TIME = seq(0, 24, by = 0.5), CONC = NA), regimen = regimen, se = TRUE ) library(ggplot2) ggplot(data, aes(x=TIME, y=CONC)) + geom_ribbon(aes(fill=&quot;Population&quot;, ymin=CONC.lower, ymax=CONC.upper), fill=&quot;steelblue2&quot;, alpha=0.15) + geom_line(aes(color=&quot;Population&quot;), data=data) + scale_color_manual(values=c(&quot;steelblue2&quot;)) + scale_y_log10() pred &lt;- estimate(tdmore, regimen = regimen) coef(pred) vcov(pred) observed &lt;- data.frame(TIME=c(9, 15), CONC=c(30, 2)) ipred &lt;- estimate(tdmore, observed = observed, regimen = regimen) coef(ipred) vcov(ipred) data &lt;- predict(ipred, newdata=data.frame(TIME=seq(0, 24, 0.1), CONC=NA), se=TRUE) ggplot(data, aes(x=TIME)) + geom_line(aes(color=&quot;Individual&quot;, y=CONC.median)) + geom_ribbon(aes(fill=&quot;Individual&quot;, ymin=CONC.lower, ymax=CONC.upper), fill=&quot;tomato1&quot;, alpha=0.10) + geom_line(aes(color=&quot;Population&quot;, y=CONC), data=predict(pred, newdata=seq(0, 24, 0.1))) + geom_point(aes(y=CONC), data=observed) + scale_color_manual(values=c(&quot;tomato1&quot;, &quot;steelblue2&quot;)) + scale_y_log10() plot(ipred, newdata=data.frame(TIME=seq(0.1, 24, by=0.1), CONC=NA)) + scale_y_log10() newRegimen &lt;- data.frame( TIME=c(0, 8, 16, 24), # A fourth dose on the second day is added AMT=c(1000, 1000, 1000, NA), # Adding an unknown dose on the second day RATE=c(1000, 1000, 1000, 1000)/0.5 # 30-minute infusion (rate=dose/infusion time) ) recommendation &lt;- findDose( ipred, regimen = newRegimen, interval = c(100, 5000), target = data.frame(TIME = 32, CONC = 8) ) summary(recommendation) # Recommended regimen for individual can be directly accessed from the recommendation object ipredRecommendedRegimen &lt;- recommendation$regimen # Population regimen can be updated using the &#39;updateRegimen&#39; method, a 4th dose of 1000 is used predUpdatedRegimen &lt;- updateRegimen(regimen = newRegimen, newDose = 4500) print(predUpdatedRegimen) # Check pred regimen ipred &lt;- estimate(tdmore, observed = observed, regimen = ipredRecommendedRegimen) pred &lt;- estimate(tdmore, regimen = predUpdatedRegimen) plot(ipred, newdata=seq(0, 32, by=0.1)) + geom_hline(yintercept=8) + scale_y_log10() set.seed(0) library(nlmixr) modelCode &lt;- function(){ ini({ TVCL &lt;- 34.1 TVVc &lt;- 2700 TVKa &lt;- 0.126 TVVp &lt;- 774 TVQ &lt;- 0.688 ECL ~ 0.060516 # 24.6% EVc ~ 0.052900 # 23.0% EKa ~ 2.755600 # 166% EPS_Prop &lt;- 0.417 }) model({ CL &lt;- TVCL * exp(ECL) Vc &lt;- TVVc * exp(EVc) Vp &lt;- TVVp Q &lt;- TVQ K12 &lt;- Q/Vc K21 &lt;- Q/Vp Ke &lt;- CL/Vc Ka &lt;- TVKa*exp(EKa) d/dt(depot) = -Ka*depot d/dt(center) = Ka*depot - Ke*center - K12*center + K21*periph d/dt(periph) = K12*center - K21*periph CONC = center/Vc CONC ~ prop(EPS_Prop) }) } library(tdmore) nlmixrModel &lt;- nlmixrUI(modelCode) m1 &lt;- tdmore(nlmixrModel) regimen &lt;- data.frame( TIME=0, # First dose time: t=0h AMT=50, # Dose amount: 50 mg II=24, # Dose interval: 24h ADDL=4*7-1 # Additional doses: 4 weeks ) times &lt;- seq(0, 6*7*24) # Observation times plot(m1, regimen, newdata=times) modelCode &lt;- function(){ ini({ # PK model sunitinib TVCL &lt;- 34.1 TVVc &lt;- 2700 TVKa &lt;- 0.126 TVVp &lt;- 774 TVQ &lt;- 0.688 ECL ~ 0.060516 # 24.6% EVc ~ 0.052900 # 23.0% EKa ~ 2.755600 # 166% EPS_Prop &lt;- 0.417 # Proportional error 1 (related to CONC) # PD model ALT TVBASE_AST &lt;- 21.5 TVKout_AST &lt;- 0.0142 TVKpd_AST &lt;- 0.00572 EPS_Prop_AST = 0.257 #25.7% # PD model AST TVBASE_ALT &lt;- 21.2 TVKout_ALT &lt;- 0.00916 TVKpd_ALT &lt;- 0.00401 EPS_Prop_ALT = 0.373 #37.3% # We assume 0.5 correlations in IIV, even though they are not reported in the original paper EBASE_AST + EBASE_ALT ~ c(0.101124, 0.05028021, 0.164025) # 31.8% #40.5% EKout_AST + EKout_ALT ~ c(1.440000, 0.1897367, 1.638400)#120% #128% EKpd_AST + EKpd_ALT ~ c(0.114244, 0.05344249, 0.324900) #33.8% #57.0% }) model({ # PK parameters CL &lt;- TVCL * exp(ECL) Vc &lt;- TVVc * exp(EVc) Vp &lt;- TVVp Q &lt;- TVQ K12 &lt;- Q/Vc K21 &lt;- Q/Vp Ke &lt;- CL/Vc Ka &lt;- TVKa*exp(EKa) # AST parameters BASE_AST &lt;- TVBASE_AST * exp(EBASE_AST) Kout_AST &lt;- TVKout_AST * exp(EKout_AST) Kpd_AST &lt;- TVKpd_AST * exp(EKpd_AST) #mL/ng Kin_AST &lt;- Kout_AST * BASE_AST # ALT parameters BASE_ALT &lt;- TVBASE_ALT * exp(EBASE_ALT) Kout_ALT &lt;- TVKout_ALT * exp(EKout_ALT) Kpd_ALT &lt;- TVKpd_ALT * exp(EKpd_ALT) #mL/ng Kin_ALT &lt;- Kout_ALT * BASE_ALT # PK model d/dt(depot) = -Ka*depot d/dt(center) = Ka*depot - Ke*center - K12*center + K21*periph d/dt(periph) = K12*center - K21*periph CONC = center/Vc * 1000 #ng/mL # AST model AST(0) = BASE_AST d/dt(AST) = Kin_AST - Kout_AST*AST*(1-Kpd_AST*CONC) # ALT model ALT(0) = BASE_ALT d/dt(ALT) = Kin_ALT - Kout_ALT*ALT*(1-Kpd_ALT*CONC) # Residual error models CONC ~ prop(EPS_Prop) | center # Define error model 1 AST ~ prop(EPS_Prop_AST) | AST # error model 2 ALT ~ prop(EPS_Prop_ALT) | ALT # error model 3 }) } nlmixrModel &lt;- nlmixrUI(modelCode) m2 &lt;- tdmore(nlmixrModel, maxsteps=1E3*500) regimen &lt;- data.frame( TIME=0, AMT=50, II=24, ADDL=4*7 ) times &lt;- seq(0, 6*7*24, by=1) plot(m2, regimen, newdata=data.frame(TIME=times, CONC=NA)) plot(m2, regimen, newdata=data.frame(TIME=times, ALT=NA)) plot(m2, regimen, newdata=data.frame(TIME=times, AST=NA)) observed &lt;- data.frame( TIME=c(0, 2,3,4)*7*24, CONC=NA, ALT=c(21, 40, 42, 43), AST=c(21, 45, 47, 49)) ipred &lt;- estimate(m2, observed = observed, regimen = regimen) plot(ipred, newdata=data.frame(TIME=times, CONC=NA)) plot(ipred, newdata=data.frame(TIME=times, ALT=NA)) plot(ipred, newdata=data.frame(TIME=times, AST=NA)) coef(ipred) coef(ipred) / sqrt(diag(m2$omega)) set.seed(0) library(nlmixr) modelCode &lt;- function(){ ini({ TVKa &lt;- 3.87 TVCL &lt;- 659 #L/h TVV1 &lt;- 56900 #L TVV2 &lt;- 5550 #L TVQ &lt;- 259 #L/h EKa ~ 0.04507129 #0.2123**2 ECL ~ 0.1535856 #0.3919**2 EV1 ~ 0.09223369 #0.3037**2 EV2 ~ 0.208301 #0.4564**2 EQ ~ 0.1015697# 0.3187**2 EPS_ADD &lt;- 1.91 # EPS_PROP &lt;- 0.117 }) model({ Ka &lt;- TVKa * exp(EKa) CL &lt;- TVCL * exp(ECL) V1 &lt;- TVV1 * exp(EV1) V2 &lt;- TVV2 * exp(EV2) Q &lt;- TVQ * exp(EQ) K12 &lt;- Q/V1 K21 &lt;- Q/V2 d/dt(center) = - CL/V1 * center - K12*center + K21 * periph d/dt(periph) = K12*center - K21 * periph CONC = center / V1 * 1000 CONC ~ prop(EPS_PROP) + add(EPS_ADD) }) } nlmixrModel &lt;- nlmixrUI(modelCode) library(tdmore) m1 &lt;- tdmore(nlmixrModel) regimen &lt;- data.frame( TIME=seq(0, by=24, length.out=30), AMT=500 # 500ug standard dose ) adhering &lt;- predict(m1, regimen=regimen, newdata=seq(0, 30*24)) actual &lt;- data.frame( TIME=seq(0, by=24, length.out=30), AMT=500*sample(c(0,1), 30, replace=TRUE) # probability of 50% to not take the dose ) nonAdhering &lt;- predict(m1, regimen=actual, newdata=seq(0, 30*24)) library(ggplot2) pred &lt;- estimate(m1, regimen=regimen) ggplot(mapping=aes(x=TIME, y=CONC)) + geom_line(aes(color=&quot;Adhering&quot;), data=adhering) + geom_line(aes(color=&quot;Non-adhering&quot;), data=nonAdhering) # Take a blood sample observed &lt;- predict(m1, regimen=actual, newdata=data.frame(TIME=30*24+c(-16, 0), CONC=NA)) observed # We estimate individual parameters # as if the virtual subject took his medication # properly ipred &lt;- estimate(m1, observed, regimen) coef(ipred) ggplot(mapping=aes(x=TIME, y=CONC)) + geom_line(aes(color=&quot;Reality&quot;), data=nonAdhering) + geom_point(data=observed) + geom_line(aes(color=&quot;Population&quot;), data=adhering) + # geom_ribbon(aes(fill=&quot;Population&quot;, ymin=CONC.lower, ymax=CONC.upper), # data=predict(m1, regimen=regimen, newdata=data.frame(TIME=seq(0, 30*24), CONC=NA), se.fit=TRUE), alpha=0.1) + geom_line(aes(color=&quot;Prediction&quot;), data=predict(ipred, regimen=regimen, newdata=data.frame(TIME=seq(0, 30*24), CONC=NA))) standardDeviations &lt;- coef(ipred) / sqrt(diag(m1$omega)) standardDeviations i &lt;- which(pnorm(abs(standardDeviations)) &gt; 0.975) if(length(i) &gt; 0) { cat(&quot;This subject has unlikely (outside 95% CI) parameter estimates for &quot;, names(i),&quot;. There may be a treatment adherence issue.&quot;) } "]
]
